<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>å°æ–°ç”»ç”»æ¿ Pro - ä¸“ä¸šç‰ˆ ğŸ¨</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #FF6B6B;
            --secondary-color: #4ECDC4;
            --accent-color: #FFE66D;
            --dark-bg: #2C3E50;
            --light-bg: #ECF0F1;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --shadow: 0 4px 20px rgba(0,0,0,0.1);
            --radius: 12px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        /* é¡¶éƒ¨å·¥å…·æ  */
        .top-toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
            gap: 20px;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tool-section {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 0 15px;
            border-left: 1px solid rgba(0,0,0,0.1);
        }

        .tool-section:first-child {
            border-left: none;
        }

        /* å·¦ä¾§å·¥å…·é¢æ¿ */
        .left-panel {
            position: fixed;
            left: 0;
            top: 60px;
            bottom: 0;
            width: 80px;
            background: var(--panel-bg);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 20px 10px;
            z-index: 999;
            overflow-y: auto;
        }

        .tool-btn {
            width: 60px;
            height: 60px;
            border: 2px solid transparent;
            border-radius: var(--radius);
            background: white;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.3s ease;
            position: relative;
        }

        .tool-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            border-color: var(--primary-color);
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: transparent;
        }

        .tool-btn .icon {
            font-size: 24px;
        }

        .tool-btn .label {
            font-size: 10px;
            font-weight: 600;
        }

        /* å³ä¾§å±æ€§é¢æ¿ */
        .right-panel {
            position: fixed;
            right: 0;
            top: 60px;
            bottom: 0;
            width: 280px;
            background: var(--panel-bg);
            box-shadow: var(--shadow);
            z-index: 999;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-section {
            background: white;
            border-radius: var(--radius);
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* ç”»å¸ƒå®¹å™¨ */
        .canvas-container {
            position: fixed;
            left: 80px;
            right: 280px;
            top: 60px;
            bottom: 0;
            overflow: hidden;
            background: #f5f5f5;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-viewport {
            position: relative;
            background: white;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            border-radius: 4px;
            transform-origin: center center;
        }

        #mainCanvas {
            display: block;
            cursor: crosshair;
        }

        /* å›¾å±‚é¢æ¿ */
        .layers-panel {
            max-height: 300px;
            overflow-y: auto;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .layer-item:hover {
            background: #e9ecef;
        }

        .layer-item.active {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border: 1px solid #667eea;
        }

        .layer-thumbnail {
            width: 40px;
            height: 40px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: white;
        }

        .layer-info {
            flex: 1;
        }

        .layer-name {
            font-size: 12px;
            font-weight: 500;
            color: #333;
        }

        .layer-opacity {
            font-size: 10px;
            color: #6c757d;
        }

        .layer-controls {
            display: flex;
            gap: 5px;
        }

        .layer-control-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .layer-control-btn:hover {
            background: rgba(0,0,0,0.05);
        }

        /* ç¬”åˆ·é¢„è®¾ */
        .brush-presets {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .brush-preset {
            aspect-ratio: 1;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            background: white;
            position: relative;
            overflow: hidden;
            transition: all 0.2s;
        }

        .brush-preset:hover {
            border-color: var(--primary-color);
            transform: scale(1.05);
        }

        .brush-preset.active {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .brush-preset canvas {
            width: 100%;
            height: 100%;
        }

        /* è‰²å½©é€‰æ‹©å™¨ */
        .color-picker-advanced {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .color-mode-tabs {
            display: flex;
            gap: 5px;
            background: #f1f3f4;
            padding: 3px;
            border-radius: 8px;
        }

        .color-mode-tab {
            flex: 1;
            padding: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .color-mode-tab.active {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .color-wheel {
            width: 100%;
            height: 200px;
            border-radius: 50%;
            position: relative;
            margin: 10px auto;
        }

        .color-slider {
            width: 100%;
            margin: 8px 0;
        }

        .color-input-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .color-input {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .color-input label {
            font-size: 10px;
            color: #6c757d;
            font-weight: 500;
        }

        .color-input input {
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 12px;
        }

        /* ç¬”åˆ·å‚æ•°æ§åˆ¶ */
        .brush-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-label {
            font-size: 11px;
            color: #6c757d;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-value {
            font-size: 11px;
            color: #333;
            font-weight: 600;
        }

        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #e9ecef;
            outline: none;
            transition: background 0.3s;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* å¯¹ç§°æ¨¡å¼æ§åˆ¶ */
        .symmetry-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .symmetry-mode {
            padding: 8px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            background: white;
        }

        .symmetry-mode:hover {
            border-color: var(--primary-color);
        }

        .symmetry-mode.active {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
        }

        .symmetry-mode .icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .symmetry-mode .name {
            font-size: 10px;
            color: #6c757d;
        }

        /* æµ®åŠ¨å·¥å…·æç¤º */
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .tooltip.show {
            opacity: 1;
        }

        /* å¿«æ·é”®æç¤º */
        .shortcut-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 12px;
            display: none;
            z-index: 1000;
        }

        .shortcut-hint.show {
            display: block;
            animation: fadeInUp 0.3s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        /* åŠ è½½åŠ¨ç”» */
        .loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 10000;
        }

        .loader.show {
            display: block;
        }

        .loader-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(102, 126, 234, 0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* å“åº”å¼è®¾è®¡ */
        @media (max-width: 1024px) {
            .right-panel {
                width: 240px;
            }

            .left-panel {
                width: 60px;
            }

            .tool-btn {
                width: 50px;
                height: 50px;
            }

            .tool-btn .icon {
                font-size: 20px;
            }

            .tool-btn .label {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .right-panel {
                position: fixed;
                right: -280px;
                transition: right 0.3s;
            }

            .right-panel.open {
                right: 0;
            }

            .canvas-container {
                right: 0;
            }
        }

        /* é«˜çº§æ··åˆæ¨¡å¼é€‰æ‹©å™¨ */
        .blend-mode-selector {
            width: 100%;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 12px;
            background: white;
            cursor: pointer;
        }

        /* æ¸å˜ç¼–è¾‘å™¨ */
        .gradient-editor {
            padding: 15px;
            background: white;
            border-radius: 8px;
            margin-top: 10px;
        }

        .gradient-preview {
            height: 40px;
            border-radius: 6px;
            margin-bottom: 15px;
            border: 1px solid #dee2e6;
        }

        .gradient-stops {
            position: relative;
            height: 20px;
            margin: 10px 0;
            border-radius: 10px;
            background: linear-gradient(to right, #000, #fff);
            cursor: pointer;
        }

        .gradient-stop {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid white;
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .gradient-stop.active {
            width: 16px;
            height: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* é€è§†ç½‘æ ¼è¦†ç›–å±‚ */
        .perspective-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* å‚è€ƒå›¾ç‰‡çª—å£ */
        .reference-window {
            position: fixed;
            width: 300px;
            height: 300px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
        }

        .reference-window.active {
            display: block;
        }

        .reference-header {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .reference-content {
            padding: 10px;
            height: calc(100% - 40px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reference-content img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* å†å²è®°å½•æ—¶é—´è½´ */
        .history-timeline {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .history-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }

        .history-item:hover {
            background: #e9ecef;
        }

        .history-item.current {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-left: 3px solid #667eea;
        }

        .history-thumbnail {
            width: 30px;
            height: 30px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: white;
        }

        .history-info {
            flex: 1;
        }

        .history-action {
            font-weight: 500;
            color: #333;
        }

        .history-time {
            font-size: 10px;
            color: #6c757d;
        }

        /* è‡ªå®šä¹‰å…‰æ ‡ */
        .custom-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: difference;
        }

        .cursor-ring {
            border: 2px solid rgba(102, 126, 234, 0.6);
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
        }

        /* æ€§èƒ½ç›‘è§†å™¨ */
        .performance-monitor {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            padding: 5px;
            border-radius: 4px;
            display: none;
            z-index: 10000;
        }

        .performance-monitor.show {
            display: block;
        }

        /* äº‘ç«¯åŒæ­¥çŠ¶æ€ */
        .sync-status {
            position: fixed;
            top: 70px;
            right: 20px;
            background: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s;
        }

        .sync-status.show {
            opacity: 1;
            transform: translateY(0);
        }

        .sync-icon {
            width: 16px;
            height: 16px;
            animation: rotate 2s linear infinite;
        }

        @keyframes rotate {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- é¡¶éƒ¨å·¥å…·æ  -->
    <div class="top-toolbar">
        <div class="logo">
            <span>ğŸ¨</span>
            <span>å°æ–°ç”»ç”»æ¿ Pro</span>
        </div>

        <div class="tool-section">
            <button class="tool-action" id="newFileBtn" title="æ–°å»º (Ctrl+N)">ğŸ“„ æ–°å»º</button>
            <button class="tool-action" id="openFileBtn" title="æ‰“å¼€ (Ctrl+O)">ğŸ“ æ‰“å¼€</button>
            <button class="tool-action" id="saveFileBtn" title="ä¿å­˜ (Ctrl+S)">ğŸ’¾ ä¿å­˜</button>
            <button class="tool-action" id="exportBtn" title="å¯¼å‡º">ğŸ“¤ å¯¼å‡º</button>
        </div>

        <div class="tool-section">
            <button class="tool-action" id="undoBtn" title="æ’¤é”€ (Ctrl+Z)">â†¶</button>
            <button class="tool-action" id="redoBtn" title="é‡åš (Ctrl+Y)">â†·</button>
            <span class="history-count">å†å²: <span id="historyCount">0/âˆ</span></span>
        </div>

        <div class="tool-section">
            <label>ç¼©æ”¾: <span id="zoomLevel">100%</span></label>
            <input type="range" id="zoomSlider" min="10" max="500" value="100" style="width: 100px;">
            <button class="tool-action" id="fitToScreenBtn" title="é€‚åº”å±å¹•">âŠ¡</button>
        </div>

        <div class="tool-section" style="margin-left: auto;">
            <button class="tool-action" id="settingsBtn">âš™ï¸ è®¾ç½®</button>
            <button class="tool-action" id="helpBtn">â“ å¸®åŠ©</button>
        </div>
    </div>

    <!-- å·¦ä¾§å·¥å…·é¢æ¿ -->
    <div class="left-panel">
        <div class="tool-btn active" data-tool="brush" title="ç”»ç¬”å·¥å…· (B)">
            <span class="icon">âœï¸</span>
            <span class="label">ç”»ç¬”</span>
        </div>
        <div class="tool-btn" data-tool="eraser" title="æ©¡çš®æ“¦ (E)">
            <span class="icon">ğŸ§¹</span>
            <span class="label">æ©¡çš®</span>
        </div>
        <div class="tool-btn" data-tool="eyedropper" title="å¸ç®¡å·¥å…· (I)">
            <span class="icon">ğŸ’‰</span>
            <span class="label">å¸ç®¡</span>
        </div>
        <div class="tool-btn" data-tool="fill" title="å¡«å……å·¥å…· (G)">
            <span class="icon">ğŸª£</span>
            <span class="label">å¡«å……</span>
        </div>
        <div class="tool-btn" data-tool="gradient" title="æ¸å˜å·¥å…· (G)">
            <span class="icon">ğŸŒˆ</span>
            <span class="label">æ¸å˜</span>
        </div>
        <div class="tool-btn" data-tool="shape" title="å½¢çŠ¶å·¥å…· (U)">
            <span class="icon">â¬œ</span>
            <span class="label">å½¢çŠ¶</span>
        </div>
        <div class="tool-btn" data-tool="text" title="æ–‡å­—å·¥å…· (T)">
            <span class="icon">ğŸ“</span>
            <span class="label">æ–‡å­—</span>
        </div>
        <div class="tool-btn" data-tool="select" title="é€‰æ‹©å·¥å…· (M)">
            <span class="icon">â¬š</span>
            <span class="label">é€‰æ‹©</span>
        </div>
        <div class="tool-btn" data-tool="transform" title="å˜æ¢å·¥å…· (Ctrl+T)">
            <span class="icon">ğŸ”„</span>
            <span class="label">å˜æ¢</span>
        </div>
        <div class="tool-btn" data-tool="symmetry" title="å¯¹ç§°ç»˜åˆ¶ (Y)">
            <span class="icon">ğŸ”®</span>
            <span class="label">å¯¹ç§°</span>
        </div>
        <div class="tool-btn" data-tool="perspective" title="é€è§†æ ‡å°º (P)">
            <span class="icon">ğŸ“</span>
            <span class="label">é€è§†</span>
        </div>
        <div class="tool-btn" data-tool="reference" title="å‚è€ƒå›¾ç‰‡ (R)">
            <span class="icon">ğŸ–¼ï¸</span>
            <span class="label">å‚è€ƒ</span>
        </div>
    </div>

    <!-- ç”»å¸ƒå®¹å™¨ -->
    <div class="canvas-container" id="canvasContainer">
        <div class="canvas-viewport" id="canvasViewport">
            <canvas id="mainCanvas"></canvas>
            <canvas id="perspectiveOverlay" class="perspective-overlay" style="display: none;"></canvas>
            <div class="custom-cursor" id="customCursor" style="display: none;">
                <div class="cursor-ring" id="cursorRing"></div>
            </div>
        </div>
    </div>

    <!-- å³ä¾§å±æ€§é¢æ¿ -->
    <div class="right-panel">
        <!-- å›¾å±‚é¢æ¿ -->
        <div class="panel-section">
            <div class="panel-title">
                <span>ğŸ“š</span>
                <span>å›¾å±‚</span>
                <button style="margin-left: auto;" id="addLayerBtn">â•</button>
            </div>
            <div class="layers-panel" id="layersPanel">
                <!-- åŠ¨æ€ç”Ÿæˆå›¾å±‚åˆ—è¡¨ -->
            </div>
            <div style="margin-top: 10px;">
                <label style="font-size: 11px;">æ··åˆæ¨¡å¼:</label>
                <select class="blend-mode-selector" id="blendModeSelect">
                    <option value="normal">æ­£å¸¸</option>
                    <option value="multiply">æ­£ç‰‡å åº•</option>
                    <option value="screen">æ»¤è‰²</option>
                    <option value="overlay">å åŠ </option>
                    <option value="soft-light">æŸ”å…‰</option>
                    <option value="hard-light">å¼ºå…‰</option>
                    <option value="color-dodge">é¢œè‰²å‡æ·¡</option>
                    <option value="color-burn">é¢œè‰²åŠ æ·±</option>
                    <option value="darken">å˜æš—</option>
                    <option value="lighten">å˜äº®</option>
                    <option value="difference">å·®å€¼</option>
                    <option value="exclusion">æ’é™¤</option>
                    <option value="hue">è‰²ç›¸</option>
                    <option value="saturation">é¥±å’Œåº¦</option>
                    <option value="color">é¢œè‰²</option>
                    <option value="luminosity">æ˜åº¦</option>
                </select>
                <div style="margin-top: 8px;">
                    <label style="font-size: 11px;">ä¸é€æ˜åº¦: <span id="layerOpacityValue">100%</span></label>
                    <input type="range" class="slider" id="layerOpacitySlider" min="0" max="100" value="100">
                </div>
            </div>
        </div>

        <!-- ç¬”åˆ·è®¾ç½® -->
        <div class="panel-section" id="brushSettings">
            <div class="panel-title">
                <span>ğŸ–Œï¸</span>
                <span>ç¬”åˆ·è®¾ç½®</span>
            </div>

            <!-- ç¬”åˆ·é¢„è®¾ -->
            <div class="brush-presets" id="brushPresets">
                <!-- åŠ¨æ€ç”Ÿæˆç¬”åˆ·é¢„è®¾ -->
            </div>

            <!-- ç¬”åˆ·å‚æ•° -->
            <div class="brush-controls" style="margin-top: 15px;">
                <div class="control-group">
                    <div class="control-label">
                        <span>å¤§å°</span>
                        <span class="control-value" id="brushSizeValue">10px</span>
                    </div>
                    <input type="range" class="slider" id="brushSizeSlider" min="1" max="500" value="10">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>ç¡¬åº¦</span>
                        <span class="control-value" id="brushHardnessValue">100%</span>
                    </div>
                    <input type="range" class="slider" id="brushHardnessSlider" min="0" max="100" value="100">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>æµé‡</span>
                        <span class="control-value" id="brushFlowValue">100%</span>
                    </div>
                    <input type="range" class="slider" id="brushFlowSlider" min="1" max="100" value="100">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>é—´è·</span>
                        <span class="control-value" id="brushSpacingValue">25%</span>
                    </div>
                    <input type="range" class="slider" id="brushSpacingSlider" min="1" max="200" value="25">
                </div>
            </div>

            <!-- åŠ¨æ€è®¾ç½® -->
            <div style="margin-top: 15px;">
                <label style="font-size: 11px; font-weight: 600;">å‹åŠ›æ„Ÿåº”:</label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 8px;">
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="pressureSize" checked> æ§åˆ¶å¤§å°
                    </label>
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="pressureOpacity" checked> æ§åˆ¶ä¸é€æ˜åº¦
                    </label>
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="pressureFlow"> æ§åˆ¶æµé‡
                    </label>
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="pressureHardness"> æ§åˆ¶ç¡¬åº¦
                    </label>
                </div>
            </div>

            <!-- å€¾æ–œæ„Ÿåº” -->
            <div style="margin-top: 15px;">
                <label style="font-size: 11px; font-weight: 600;">å€¾æ–œæ„Ÿåº”:</label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 8px;">
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="tiltAngle"> æ§åˆ¶è§’åº¦
                    </label>
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="tiltShape"> æ§åˆ¶å½¢çŠ¶
                    </label>
                </div>
            </div>

            <!-- é€Ÿåº¦æ„Ÿåº” -->
            <div style="margin-top: 15px;">
                <label style="font-size: 11px; font-weight: 600;">é€Ÿåº¦æ„Ÿåº”:</label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 8px;">
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="velocitySize"> æ§åˆ¶å¤§å°
                    </label>
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="velocitySmooth"> å¹³æ»‘å¤„ç†
                    </label>
                </div>
            </div>

            <!-- çº¹ç†è®¾ç½® -->
            <div style="margin-top: 15px;">
                <label style="font-size: 11px; font-weight: 600;">çº¹ç†:</label>
                <select style="width: 100%; margin-top: 8px; padding: 6px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 12px;" id="brushTexture">
                    <option value="none">æ— </option>
                    <option value="canvas">ç”»å¸ƒçº¹ç†</option>
                    <option value="paper">çº¸å¼ çº¹ç†</option>
                    <option value="watercolor">æ°´å½©çº¸</option>
                    <option value="rough">ç²—ç³™è¡¨é¢</option>
                    <option value="custom">è‡ªå®šä¹‰...</option>
                </select>
            </div>
        </div>

        <!-- é¢œè‰²é¢æ¿ -->
        <div class="panel-section">
            <div class="panel-title">
                <span>ğŸ¨</span>
                <span>é¢œè‰²</span>
            </div>

            <div class="color-picker-advanced">
                <!-- é¢œè‰²æ¨¡å¼åˆ‡æ¢ -->
                <div class="color-mode-tabs">
                    <button class="color-mode-tab active" data-mode="rgb">RGB</button>
                    <button class="color-mode-tab" data-mode="hsl">HSL</button>
                    <button class="color-mode-tab" data-mode="lab">Lab</button>
                    <button class="color-mode-tab" data-mode="cmyk">CMYK</button>
                </div>

                <!-- é¢œè‰²è½® -->
                <canvas id="colorWheel" class="color-wheel"></canvas>

                <!-- é¢œè‰²å€¼è¾“å…¥ -->
                <div class="color-input-group" id="rgbInputs">
                    <div class="color-input">
                        <label>R</label>
                        <input type="number" id="colorR" min="0" max="255" value="255">
                    </div>
                    <div class="color-input">
                        <label>G</label>
                        <input type="number" id="colorG" min="0" max="255" value="107">
                    </div>
                    <div class="color-input">
                        <label>B</label>
                        <input type="number" id="colorB" min="0" max="255" value="107">
                    </div>
                </div>

                <!-- æœ€è¿‘ä½¿ç”¨çš„é¢œè‰² -->
                <div style="margin-top: 15px;">
                    <label style="font-size: 11px; font-weight: 600;">æœ€è¿‘ä½¿ç”¨:</label>
                    <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; margin-top: 8px;" id="recentColors">
                        <!-- åŠ¨æ€ç”Ÿæˆæœ€è¿‘é¢œè‰² -->
                    </div>
                </div>

                <!-- è‰²æ¿ -->
                <div style="margin-top: 15px;">
                    <label style="font-size: 11px; font-weight: 600;">è‰²æ¿:</label>
                    <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; margin-top: 8px;" id="colorPalette">
                        <!-- åŠ¨æ€ç”Ÿæˆè‰²æ¿ -->
                    </div>
                </div>
            </div>
        </div>

        <!-- å¯¹ç§°æ¨¡å¼ -->
        <div class="panel-section" id="symmetrySettings" style="display: none;">
            <div class="panel-title">
                <span>ğŸ”®</span>
                <span>å¯¹ç§°ç»˜åˆ¶</span>
            </div>

            <div class="symmetry-controls">
                <div class="symmetry-mode" data-mode="none">
                    <div class="icon">â­•</div>
                    <div class="name">æ— </div>
                </div>
                <div class="symmetry-mode" data-mode="horizontal">
                    <div class="icon">â†”ï¸</div>
                    <div class="name">æ°´å¹³</div>
                </div>
                <div class="symmetry-mode" data-mode="vertical">
                    <div class="icon">â†•ï¸</div>
                    <div class="name">å‚ç›´</div>
                </div>
                <div class="symmetry-mode" data-mode="radial">
                    <div class="icon">âœ³ï¸</div>
                    <div class="name">å¾„å‘</div>
                </div>
                <div class="symmetry-mode" data-mode="kaleidoscope">
                    <div class="icon">ğŸŒº</div>
                    <div class="name">ä¸‡èŠ±ç­’</div>
                </div>
                <div class="symmetry-mode" data-mode="custom">
                    <div class="icon">âš™ï¸</div>
                    <div class="name">è‡ªå®šä¹‰</div>
                </div>
            </div>

            <div style="margin-top: 15px;">
                <label style="font-size: 11px;">åˆ†æ®µæ•°: <span id="symmetrySegments">4</span></label>
                <input type="range" class="slider" id="symmetrySegmentsSlider" min="2" max="32" value="4">
            </div>
        </div>

        <!-- é€è§†è®¾ç½® -->
        <div class="panel-section" id="perspectiveSettings" style="display: none;">
            <div class="panel-title">
                <span>ğŸ“</span>
                <span>é€è§†æ ‡å°º</span>
            </div>

            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                <button class="perspective-mode" data-points="1">1ç‚¹é€è§†</button>
                <button class="perspective-mode" data-points="2">2ç‚¹é€è§†</button>
                <button class="perspective-mode" data-points="3">3ç‚¹é€è§†</button>
                <button class="perspective-mode" data-points="custom">è‡ªå®šä¹‰</button>
            </div>

            <div style="margin-top: 15px;">
                <label style="font-size: 11px;">
                    <input type="checkbox" id="perspectiveSnap" checked> å¸é™„åˆ°é€è§†çº¿
                </label>
            </div>

            <div style="margin-top: 8px;">
                <label style="font-size: 11px;">ç½‘æ ¼å¯†åº¦: <span id="gridDensity">10</span></label>
                <input type="range" class="slider" id="gridDensitySlider" min="5" max="50" value="10">
            </div>
        </div>

        <!-- å†å²è®°å½• -->
        <div class="panel-section">
            <div class="panel-title">
                <span>â°</span>
                <span>å†å²è®°å½•</span>
            </div>
            <div class="history-timeline" id="historyTimeline">
                <!-- åŠ¨æ€ç”Ÿæˆå†å²è®°å½• -->
            </div>
        </div>
    </div>

    <!-- å‚è€ƒå›¾ç‰‡çª—å£ -->
    <div class="reference-window" id="referenceWindow">
        <div class="reference-header">
            <span>å‚è€ƒå›¾ç‰‡</span>
            <button id="closeReference">âœ–ï¸</button>
        </div>
        <div class="reference-content">
            <img id="referenceImage" src="" alt="å‚è€ƒå›¾ç‰‡">
        </div>
    </div>

    <!-- å¿«æ·é”®æç¤º -->
    <div class="shortcut-hint" id="shortcutHint"></div>

    <!-- åŠ è½½åŠ¨ç”» -->
    <div class="loader" id="loader">
        <div class="loader-spinner"></div>
    </div>

    <!-- æ€§èƒ½ç›‘è§†å™¨ -->
    <div class="performance-monitor" id="performanceMonitor">
        FPS: <span id="fps">60</span><br>
        Memory: <span id="memory">0</span> MB<br>
        Layers: <span id="layerCount">1</span>
    </div>

    <!-- äº‘ç«¯åŒæ­¥çŠ¶æ€ -->
    <div class="sync-status" id="syncStatus">
        <div class="sync-icon">ğŸ”„</div>
        <span id="syncMessage">åŒæ­¥ä¸­...</span>
    </div>

    <!-- å·¥å…·æç¤º -->
    <div class="tooltip" id="tooltip"></div>

    <script>
        // åº”ç”¨ç¨‹åºä¸»æ¨¡å—
        class DrawingApp {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d', {
                    willReadFrequently: true,
                    alpha: true
                });

                // è®¾ç½®ç”»å¸ƒå¤§å°
                this.setupCanvas();

                // åˆå§‹åŒ–å„ä¸ªæ¨¡å—
                this.brushEngine = new BrushEngine(this);
                this.layerManager = new LayerManager(this);
                this.colorSystem = new ColorSystem(this);
                this.historyManager = new HistoryManager(this);
                this.symmetryTool = new SymmetryTool(this);
                this.perspectiveTool = new PerspectiveTool(this);
                this.transformTool = new TransformTool(this);

                // å·¥å…·çŠ¶æ€
                this.currentTool = 'brush';
                this.isDrawing = false;
                this.lastPoint = null;

                // ç”»å¸ƒå˜æ¢
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;

                // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
                this.initEventListeners();

                // åˆå§‹åŒ–UI
                this.initUI();

                // æ€§èƒ½ç›‘æ§
                this.performanceMonitor = new PerformanceMonitor();

                // äº‘ç«¯åŒæ­¥ï¼ˆæ¨¡æ‹Ÿï¼‰
                this.cloudSync = new CloudSync();
            }

            setupCanvas() {
                const container = document.getElementById('canvasContainer');
                const rect = container.getBoundingClientRect();

                this.canvas.width = 1920;  // é»˜è®¤ç”»å¸ƒå¤§å°
                this.canvas.height = 1080;

                // è®¾ç½®ç”»å¸ƒæ ·å¼
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.imageRendering = 'crisp-edges';
            }

            initEventListeners() {
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));

                // è§¦æ‘¸äº‹ä»¶ï¼ˆæ”¯æŒå‹æ„Ÿï¼‰
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });

                // æŒ‡é’ˆäº‹ä»¶ï¼ˆæ”¯æŒæ›´é«˜çº§çš„å‹æ„Ÿå’Œå€¾æ–œï¼‰
                if (window.PointerEvent) {
                    this.canvas.addEventListener('pointerdown', this.handlePointerDown.bind(this));
                    this.canvas.addEventListener('pointermove', this.handlePointerMove.bind(this));
                    this.canvas.addEventListener('pointerup', this.handlePointerUp.bind(this));
                }

                // é”®ç›˜å¿«æ·é”®
                document.addEventListener('keydown', this.handleKeyDown.bind(this));
                document.addEventListener('keyup', this.handleKeyUp.bind(this));

                // æ»šè½®ç¼©æ”¾
                this.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });

                // çª—å£è°ƒæ•´
                window.addEventListener('resize', this.handleResize.bind(this));
            }

            initUI() {
                // å·¥å…·æŒ‰é’®
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.selectTool(btn.dataset.tool);
                    });
                });

                // ç¬”åˆ·è®¾ç½®
                this.initBrushControls();

                // å›¾å±‚ç®¡ç†
                this.layerManager.initUI();

                // é¢œè‰²ç³»ç»Ÿ
                this.colorSystem.initUI();

                // å†å²è®°å½•
                this.historyManager.initUI();

                // ç¼©æ”¾æ§åˆ¶
                this.initZoomControls();

                // æ–‡ä»¶æ“ä½œ
                this.initFileControls();
            }

            initBrushControls() {
                // ç¬”åˆ·å¤§å°
                const sizeSlider = document.getElementById('brushSizeSlider');
                sizeSlider.addEventListener('input', (e) => {
                    this.brushEngine.setSize(e.target.value);
                    document.getElementById('brushSizeValue').textContent = e.target.value + 'px';
                });

                // ç¡¬åº¦
                const hardnessSlider = document.getElementById('brushHardnessSlider');
                hardnessSlider.addEventListener('input', (e) => {
                    this.brushEngine.setHardness(e.target.value / 100);
                    document.getElementById('brushHardnessValue').textContent = e.target.value + '%';
                });

                // æµé‡
                const flowSlider = document.getElementById('brushFlowSlider');
                flowSlider.addEventListener('input', (e) => {
                    this.brushEngine.setFlow(e.target.value / 100);
                    document.getElementById('brushFlowValue').textContent = e.target.value + '%';
                });

                // é—´è·
                const spacingSlider = document.getElementById('brushSpacingSlider');
                spacingSlider.addEventListener('input', (e) => {
                    this.brushEngine.setSpacing(e.target.value / 100);
                    document.getElementById('brushSpacingValue').textContent = e.target.value + '%';
                });

                // å‹åŠ›æ„Ÿåº”
                document.getElementById('pressureSize').addEventListener('change', (e) => {
                    this.brushEngine.pressureSettings.size = e.target.checked;
                });

                document.getElementById('pressureOpacity').addEventListener('change', (e) => {
                    this.brushEngine.pressureSettings.opacity = e.target.checked;
                });

                document.getElementById('pressureFlow').addEventListener('change', (e) => {
                    this.brushEngine.pressureSettings.flow = e.target.checked;
                });

                document.getElementById('pressureHardness').addEventListener('change', (e) => {
                    this.brushEngine.pressureSettings.hardness = e.target.checked;
                });

                // å€¾æ–œæ„Ÿåº”
                document.getElementById('tiltAngle').addEventListener('change', (e) => {
                    this.brushEngine.tiltSettings.angle = e.target.checked;
                });

                document.getElementById('tiltShape').addEventListener('change', (e) => {
                    this.brushEngine.tiltSettings.shape = e.target.checked;
                });

                // é€Ÿåº¦æ„Ÿåº”
                document.getElementById('velocitySize').addEventListener('change', (e) => {
                    this.brushEngine.velocitySettings.size = e.target.checked;
                });

                document.getElementById('velocitySmooth').addEventListener('change', (e) => {
                    this.brushEngine.velocitySettings.smooth = e.target.checked;
                });

                // çº¹ç†
                document.getElementById('brushTexture').addEventListener('change', (e) => {
                    this.brushEngine.setTexture(e.target.value);
                });

                // ç”Ÿæˆç¬”åˆ·é¢„è®¾
                this.generateBrushPresets();
            }

            generateBrushPresets() {
                const presetsContainer = document.getElementById('brushPresets');
                const presets = [
                    { name: 'é“…ç¬”', type: 'pencil', size: 2, hardness: 0.8 },
                    { name: 'é’¢ç¬”', type: 'pen', size: 5, hardness: 1 },
                    { name: 'é©¬å…‹ç¬”', type: 'marker', size: 15, hardness: 0.5 },
                    { name: 'æ°´å½©', type: 'watercolor', size: 20, hardness: 0.2 },
                    { name: 'æ²¹ç”»', type: 'oil', size: 30, hardness: 0.7 },
                    { name: 'ç²‰ç¬”', type: 'chalk', size: 25, hardness: 0.3 },
                    { name: 'å–·æª', type: 'airbrush', size: 40, hardness: 0.1 },
                    { name: 'çº¹ç†ç¬”', type: 'textured', size: 35, hardness: 0.6 }
                ];

                presets.forEach(preset => {
                    const div = document.createElement('div');
                    div.className = 'brush-preset';
                    div.title = preset.name;
                    div.dataset.preset = JSON.stringify(preset);

                    const canvas = document.createElement('canvas');
                    canvas.width = 50;
                    canvas.height = 50;
                    this.drawBrushPreview(canvas, preset);

                    div.appendChild(canvas);
                    div.addEventListener('click', () => {
                        this.brushEngine.loadPreset(preset);
                        document.querySelectorAll('.brush-preset').forEach(p => p.classList.remove('active'));
                        div.classList.add('active');
                    });

                    presetsContainer.appendChild(div);
                });
            }

            drawBrushPreview(canvas, preset) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // ç»˜åˆ¶é¢„è§ˆç¬”è§¦
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = preset.size / 2;
                ctx.lineCap = 'round';
                ctx.globalAlpha = preset.hardness;

                ctx.beginPath();
                ctx.moveTo(10, 40);
                ctx.quadraticCurveTo(25, 10, 40, 40);
                ctx.stroke();
            }

            initZoomControls() {
                const zoomSlider = document.getElementById('zoomSlider');
                zoomSlider.addEventListener('input', (e) => {
                    this.setZoom(e.target.value / 100);
                });

                document.getElementById('fitToScreenBtn').addEventListener('click', () => {
                    this.fitToScreen();
                });
            }

            initFileControls() {
                document.getElementById('newFileBtn').addEventListener('click', () => {
                    if (confirm('åˆ›å»ºæ–°æ–‡ä»¶å°†æ¸…ç©ºå½“å‰ç”»å¸ƒï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ')) {
                        this.newFile();
                    }
                });

                document.getElementById('openFileBtn').addEventListener('click', () => {
                    this.openFile();
                });

                document.getElementById('saveFileBtn').addEventListener('click', () => {
                    this.saveFile();
                });

                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.exportImage();
                });
            }

            selectTool(tool) {
                this.currentTool = tool;

                // æ›´æ–°UI
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tool === tool);
                });

                // æ˜¾ç¤º/éšè—ç›¸å…³è®¾ç½®é¢æ¿
                document.getElementById('brushSettings').style.display =
                    (tool === 'brush' || tool === 'eraser') ? 'block' : 'none';
                document.getElementById('symmetrySettings').style.display =
                    tool === 'symmetry' ? 'block' : 'none';
                document.getElementById('perspectiveSettings').style.display =
                    tool === 'perspective' ? 'block' : 'none';

                // æ›´æ–°å…‰æ ‡
                this.updateCursor();
            }

            updateCursor() {
                const cursor = document.getElementById('customCursor');
                const ring = document.getElementById('cursorRing');

                if (this.currentTool === 'brush' || this.currentTool === 'eraser') {
                    cursor.style.display = 'block';
                    ring.style.width = this.brushEngine.size + 'px';
                    ring.style.height = this.brushEngine.size + 'px';
                } else {
                    cursor.style.display = 'none';
                }
            }

            handleMouseDown(e) {
                this.startDrawing(e);
            }

            handleMouseMove(e) {
                this.continueDrawing(e);
                this.updateCustomCursor(e);
            }

            handleMouseUp(e) {
                this.stopDrawing(e);
            }

            handleTouchStart(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    this.startDrawing(e.touches[0]);
                }
            }

            handleTouchMove(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    this.continueDrawing(e.touches[0]);
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                this.stopDrawing(e.changedTouches[0]);
            }

            handlePointerDown(e) {
                this.pointerPressure = e.pressure || 1;
                this.pointerTiltX = e.tiltX || 0;
                this.pointerTiltY = e.tiltY || 0;
                this.startDrawing(e);
            }

            handlePointerMove(e) {
                this.pointerPressure = e.pressure || 1;
                this.pointerTiltX = e.tiltX || 0;
                this.pointerTiltY = e.tiltY || 0;
                this.continueDrawing(e);
                this.updateCustomCursor(e);
            }

            handlePointerUp(e) {
                this.stopDrawing(e);
            }

            handleKeyDown(e) {
                // å¿«æ·é”®å¤„ç†
                const shortcuts = {
                    'b': () => this.selectTool('brush'),
                    'e': () => this.selectTool('eraser'),
                    'i': () => this.selectTool('eyedropper'),
                    'g': () => this.selectTool('fill'),
                    't': () => this.selectTool('text'),
                    'm': () => this.selectTool('select'),
                    'y': () => this.selectTool('symmetry'),
                    'p': () => this.selectTool('perspective'),
                    'r': () => this.selectTool('reference'),
                    'z': () => e.ctrlKey && this.historyManager.undo(),
                    'y': () => e.ctrlKey && this.historyManager.redo(),
                    's': () => e.ctrlKey && this.saveFile(),
                    'o': () => e.ctrlKey && this.openFile(),
                    'n': () => e.ctrlKey && this.newFile(),
                    '[': () => this.brushEngine.decreaseSize(),
                    ']': () => this.brushEngine.increaseSize(),
                };

                const key = e.key.toLowerCase();
                if (shortcuts[key]) {
                    e.preventDefault();
                    shortcuts[key]();

                    // æ˜¾ç¤ºå¿«æ·é”®æç¤º
                    this.showShortcutHint(key);
                }

                // Shifté”®æŒ‰ä½æ—¶åˆ‡æ¢åˆ°å¸ç®¡å·¥å…·
                if (e.key === 'Alt' && !this.altPressed) {
                    this.altPressed = true;
                    this.previousTool = this.currentTool;
                    this.selectTool('eyedropper');
                }
            }

            handleKeyUp(e) {
                if (e.key === 'Alt' && this.altPressed) {
                    this.altPressed = false;
                    this.selectTool(this.previousTool);
                }
            }

            handleWheel(e) {
                e.preventDefault();

                if (e.ctrlKey) {
                    // ç¼©æ”¾
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.setZoom(this.zoom * delta);
                } else {
                    // å¹³ç§»
                    this.panX += e.deltaX;
                    this.panY += e.deltaY;
                    this.updateViewport();
                }
            }

            handleResize() {
                this.updateViewport();
            }

            startDrawing(e) {
                const point = this.getCanvasPoint(e);
                this.isDrawing = true;
                this.lastPoint = point;

                // è®°å½•èµ·å§‹æ—¶é—´ï¼ˆç”¨äºé€Ÿåº¦è®¡ç®—ï¼‰
                this.lastTime = performance.now();
                this.velocity = 0;

                // ä¿å­˜å†å²çŠ¶æ€
                this.historyManager.saveState();

                // æ ¹æ®å·¥å…·æ‰§è¡Œç›¸åº”æ“ä½œ
                switch (this.currentTool) {
                    case 'brush':
                    case 'eraser':
                        this.brushEngine.startStroke(point, this.getInputData(e));
                        break;
                    case 'eyedropper':
                        this.colorSystem.pickColor(point);
                        break;
                    case 'fill':
                        this.fillArea(point);
                        break;
                    // ... å…¶ä»–å·¥å…·
                }
            }

            continueDrawing(e) {
                const point = this.getCanvasPoint(e);

                // è®¡ç®—é€Ÿåº¦
                const now = performance.now();
                const dt = now - this.lastTime;
                const distance = this.lastPoint ?
                    Math.sqrt(Math.pow(point.x - this.lastPoint.x, 2) +
                             Math.pow(point.y - this.lastPoint.y, 2)) : 0;
                this.velocity = distance / dt;
                this.lastTime = now;

                if (this.isDrawing) {
                    switch (this.currentTool) {
                        case 'brush':
                        case 'eraser':
                            if (this.lastPoint) {
                                this.brushEngine.continueStroke(
                                    this.lastPoint,
                                    point,
                                    this.getInputData(e)
                                );
                            }
                            break;
                        // ... å…¶ä»–å·¥å…·
                    }
                }

                this.lastPoint = point;
            }

            stopDrawing(e) {
                if (this.isDrawing) {
                    this.isDrawing = false;

                    switch (this.currentTool) {
                        case 'brush':
                        case 'eraser':
                            this.brushEngine.endStroke();
                            break;
                        // ... å…¶ä»–å·¥å…·
                    }

                    // æ›´æ–°å›¾å±‚ç¼©ç•¥å›¾
                    this.layerManager.updateThumbnails();
                }
            }

            getCanvasPoint(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.zoom - this.panX;
                const y = (e.clientY - rect.top) / this.zoom - this.panY;
                return { x, y };
            }

            getInputData(e) {
                return {
                    pressure: this.pointerPressure || (e.pressure || 1),
                    tiltX: this.pointerTiltX || (e.tiltX || 0),
                    tiltY: this.pointerTiltY || (e.tiltY || 0),
                    velocity: this.velocity || 0,
                    time: performance.now()
                };
            }

            updateCustomCursor(e) {
                const cursor = document.getElementById('customCursor');
                if (cursor.style.display !== 'none') {
                    cursor.style.left = e.clientX + 'px';
                    cursor.style.top = e.clientY + 'px';
                }
            }

            setZoom(zoom) {
                this.zoom = Math.max(0.1, Math.min(5, zoom));
                document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
                document.getElementById('zoomSlider').value = Math.round(this.zoom * 100);
                this.updateViewport();
            }

            fitToScreen() {
                const container = document.getElementById('canvasContainer');
                const containerRect = container.getBoundingClientRect();

                const scaleX = containerRect.width / this.canvas.width;
                const scaleY = containerRect.height / this.canvas.height;
                const scale = Math.min(scaleX, scaleY) * 0.9;

                this.setZoom(scale);
                this.panX = 0;
                this.panY = 0;
                this.updateViewport();
            }

            updateViewport() {
                const viewport = document.getElementById('canvasViewport');
                viewport.style.transform = `scale(${this.zoom}) translate(${this.panX}px, ${this.panY}px)`;
            }

            showShortcutHint(key) {
                const hint = document.getElementById('shortcutHint');
                const shortcuts = {
                    'b': 'ç”»ç¬”å·¥å…·',
                    'e': 'æ©¡çš®æ“¦',
                    'i': 'å¸ç®¡å·¥å…·',
                    // ... å…¶ä»–å¿«æ·é”®
                };

                hint.textContent = shortcuts[key] || key.toUpperCase();
                hint.classList.add('show');

                setTimeout(() => {
                    hint.classList.remove('show');
                }, 1500);
            }

            fillArea(point) {
                // å®ç°æ™ºèƒ½å¡«å……ç®—æ³•
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const targetColor = this.getPixelColor(imageData, Math.floor(point.x), Math.floor(point.y));
                const fillColor = this.colorSystem.getCurrentColor();

                // ä½¿ç”¨æ”¹è¿›çš„å¡«å……ç®—æ³•ï¼ˆæ”¯æŒå®¹å·®ï¼‰
                this.floodFill(imageData, point.x, point.y, targetColor, fillColor, 10);

                this.ctx.putImageData(imageData, 0, 0);
            }

            floodFill(imageData, x, y, targetColor, fillColor, tolerance) {
                // å®ç°å¸¦å®¹å·®çš„æ´ªæ°´å¡«å……ç®—æ³•
                // ... ç®—æ³•å®ç°
            }

            getPixelColor(imageData, x, y) {
                const index = (y * imageData.width + x) * 4;
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2],
                    a: imageData.data[index + 3]
                };
            }

            newFile() {
                this.layerManager.clear();
                this.historyManager.clear();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            openFile() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*,.psd';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadFile(file);
                    }
                };
                input.click();
            }

            loadFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (file.name.endsWith('.psd')) {
                        // å¤„ç†PSDæ–‡ä»¶
                        this.loadPSDFile(e.target.result);
                    } else {
                        // å¤„ç†æ™®é€šå›¾ç‰‡
                        const img = new Image();
                        img.onload = () => {
                            this.canvas.width = img.width;
                            this.canvas.height = img.height;
                            this.ctx.drawImage(img, 0, 0);
                            this.historyManager.saveState();
                        };
                        img.src = e.target.result;
                    }
                };
                reader.readAsDataURL(file);
            }

            loadPSDFile(data) {
                // å®ç°PSDæ–‡ä»¶è§£æ
                console.log('PSDæ–‡ä»¶æ”¯æŒæ­£åœ¨å¼€å‘ä¸­...');
            }

            saveFile() {
                // ä¿å­˜ä¸ºä¸“æœ‰æ ¼å¼ï¼ˆåŒ…å«å›¾å±‚ä¿¡æ¯ï¼‰
                const projectData = {
                    version: '1.0',
                    canvas: {
                        width: this.canvas.width,
                        height: this.canvas.height
                    },
                    layers: this.layerManager.exportLayers(),
                    history: this.historyManager.exportHistory()
                };

                const blob = new Blob([JSON.stringify(projectData)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `drawing_${Date.now()}.xhp`;
                a.click();
                URL.revokeObjectURL(url);
            }

            exportImage() {
                const canvas = document.createElement('canvas');
                canvas.width = this.canvas.width;
                canvas.height = this.canvas.height;
                const ctx = canvas.getContext('2d');

                // åˆå¹¶æ‰€æœ‰å›¾å±‚
                this.layerManager.renderAllLayers(ctx);

                // å¯¼å‡ºä¸ºPNG
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `export_${Date.now()}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                }, 'image/png');
            }
        }

        // ç¬”åˆ·å¼•æ“
        class BrushEngine {
            constructor(app) {
                this.app = app;
                this.ctx = app.ctx;

                // åŸºç¡€å‚æ•°
                this.size = 10;
                this.hardness = 1;
                this.flow = 1;
                this.spacing = 0.25;
                this.smoothing = 0.5;

                // å‹åŠ›æ„Ÿåº”è®¾ç½®
                this.pressureSettings = {
                    size: true,
                    opacity: true,
                    flow: false,
                    hardness: false
                };

                // å€¾æ–œæ„Ÿåº”è®¾ç½®
                this.tiltSettings = {
                    angle: false,
                    shape: false
                };

                // é€Ÿåº¦æ„Ÿåº”è®¾ç½®
                this.velocitySettings = {
                    size: false,
                    smooth: false
                };

                // çº¹ç†
                this.texture = null;
                this.textureStrength = 0.5;

                // ç¬”è§¦ç¼“å†²
                this.strokeBuffer = [];
                this.lastStamp = null;

                // è‡ªç„¶åª’ä»‹æ¨¡æ‹Ÿ
                this.wetness = 0;
                this.bleedAmount = 0;
                this.paperTexture = null;

                // åˆå§‹åŒ–çº¹ç†
                this.initTextures();
            }

            initTextures() {
                // åˆ›å»ºç¨‹åºåŒ–çº¹ç†
                this.textures = {
                    canvas: this.createCanvasTexture(),
                    paper: this.createPaperTexture(),
                    watercolor: this.createWatercolorTexture(),
                    rough: this.createRoughTexture()
                };
            }

            createCanvasTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // ç”Ÿæˆç”»å¸ƒçº¹ç†å›¾æ¡ˆ
                for (let i = 0; i < 256; i += 4) {
                    for (let j = 0; j < 256; j += 4) {
                        ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1})`;
                        ctx.fillRect(i, j, 2, 2);
                    }
                }

                return canvas;
            }

            createPaperTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // ç”Ÿæˆçº¸å¼ çº¹ç†
                const imageData = ctx.createImageData(256, 256);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const noise = Math.random() * 20;
                    imageData.data[i] = 255 - noise;
                    imageData.data[i + 1] = 255 - noise;
                    imageData.data[i + 2] = 255 - noise;
                    imageData.data[i + 3] = 255;
                }
                ctx.putImageData(imageData, 0, 0);

                return canvas;
            }

            createWatercolorTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // ç”Ÿæˆæ°´å½©çº¹ç†
                for (let i = 0; i < 50; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.05})`;
                    ctx.beginPath();
                    ctx.arc(
                        Math.random() * 256,
                        Math.random() * 256,
                        Math.random() * 30 + 10,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }

                return canvas;
            }

            createRoughTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // ç”Ÿæˆç²—ç³™è¡¨é¢çº¹ç†
                for (let i = 0; i < 1000; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.2})`;
                    ctx.fillRect(
                        Math.random() * 256,
                        Math.random() * 256,
                        Math.random() * 3,
                        Math.random() * 3
                    );
                }

                return canvas;
            }

            setTexture(textureName) {
                if (textureName === 'none') {
                    this.texture = null;
                } else if (this.textures[textureName]) {
                    this.texture = this.textures[textureName];
                }
            }

            startStroke(point, inputData) {
                this.strokeBuffer = [point];
                this.lastStamp = null;

                // è®¾ç½®ç”»ç¬”æ ·å¼
                this.setupBrush(inputData);

                // ç»˜åˆ¶èµ·å§‹ç‚¹
                this.drawStamp(point, inputData);
            }

            continueStroke(from, to, inputData) {
                // å¹³æ»‘å¤„ç†
                if (this.velocitySettings.smooth) {
                    to = this.smoothPoint(from, to);
                }

                // è®¡ç®—éœ€è¦çš„å°ç« æ•°é‡
                const distance = Math.sqrt(
                    Math.pow(to.x - from.x, 2) +
                    Math.pow(to.y - from.y, 2)
                );

                const steps = Math.max(1, Math.floor(distance / (this.size * this.spacing)));

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const point = {
                        x: from.x + (to.x - from.x) * t,
                        y: from.y + (to.y - from.y) * t
                    };

                    // æ ¹æ®é€Ÿåº¦è°ƒæ•´è¾“å…¥æ•°æ®
                    const adjustedData = this.adjustInputData(inputData);

                    this.drawStamp(point, adjustedData);
                }

                this.strokeBuffer.push(to);
                if (this.strokeBuffer.length > 10) {
                    this.strokeBuffer.shift();
                }
            }

            endStroke() {
                // åº”ç”¨æœ€ç»ˆçš„æ··åˆæ•ˆæœ
                if (this.wetness > 0) {
                    this.applyWetEdges();
                }

                this.strokeBuffer = [];
                this.lastStamp = null;
            }

            setupBrush(inputData) {
                const ctx = this.ctx;

                // è®¾ç½®åŸºç¡€å±æ€§
                ctx.globalCompositeOperation = this.app.currentTool === 'eraser' ?
                    'destination-out' : 'source-over';

                // è®¡ç®—å®é™…å€¼
                let actualSize = this.size;
                let actualOpacity = this.flow;
                let actualHardness = this.hardness;

                // åº”ç”¨å‹åŠ›æ„Ÿåº”
                if (this.pressureSettings.size) {
                    actualSize *= (0.3 + inputData.pressure * 0.7);
                }
                if (this.pressureSettings.opacity) {
                    actualOpacity *= inputData.pressure;
                }
                if (this.pressureSettings.hardness) {
                    actualHardness *= inputData.pressure;
                }

                // åº”ç”¨é€Ÿåº¦æ„Ÿåº”
                if (this.velocitySettings.size) {
                    const velocityFactor = Math.min(1, inputData.velocity / 100);
                    actualSize *= (1 - velocityFactor * 0.5);
                }

                // åº”ç”¨å€¾æ–œæ„Ÿåº”
                if (this.tiltSettings.angle) {
                    const tiltAngle = Math.atan2(inputData.tiltY, inputData.tiltX);
                    ctx.rotate(tiltAngle);
                }

                ctx.globalAlpha = actualOpacity;

                return { actualSize, actualOpacity, actualHardness };
            }

            drawStamp(point, inputData) {
                const ctx = this.ctx;
                const { actualSize, actualOpacity, actualHardness } = this.setupBrush(inputData);

                ctx.save();

                // åˆ›å»ºç¬”åˆ·å›¾ç« 
                const stampCanvas = document.createElement('canvas');
                stampCanvas.width = actualSize * 2;
                stampCanvas.height = actualSize * 2;
                const stampCtx = stampCanvas.getContext('2d');

                // ç»˜åˆ¶ç¬”åˆ·å½¢çŠ¶
                if (actualHardness < 1) {
                    // æŸ”è¾¹ç¬”åˆ·
                    const gradient = stampCtx.createRadialGradient(
                        actualSize, actualSize, 0,
                        actualSize, actualSize, actualSize
                    );

                    gradient.addColorStop(0, `rgba(${this.app.colorSystem.currentColor.r},${this.app.colorSystem.currentColor.g},${this.app.colorSystem.currentColor.b},1)`);
                    gradient.addColorStop(actualHardness, `rgba(${this.app.colorSystem.currentColor.r},${this.app.colorSystem.currentColor.g},${this.app.colorSystem.currentColor.b},1)`);
                    gradient.addColorStop(1, `rgba(${this.app.colorSystem.currentColor.r},${this.app.colorSystem.currentColor.g},${this.app.colorSystem.currentColor.b},0)`);

                    stampCtx.fillStyle = gradient;
                    stampCtx.fillRect(0, 0, stampCanvas.width, stampCanvas.height);
                } else {
                    // ç¡¬è¾¹ç¬”åˆ·
                    stampCtx.fillStyle = `rgb(${this.app.colorSystem.currentColor.r},${this.app.colorSystem.currentColor.g},${this.app.colorSystem.currentColor.b})`;
                    stampCtx.beginPath();
                    stampCtx.arc(actualSize, actualSize, actualSize, 0, Math.PI * 2);
                    stampCtx.fill();
                }

                // åº”ç”¨çº¹ç†
                if (this.texture) {
                    stampCtx.globalCompositeOperation = 'multiply';
                    stampCtx.globalAlpha = this.textureStrength;
                    stampCtx.drawImage(this.texture, 0, 0, stampCanvas.width, stampCanvas.height);
                }

                // ç»˜åˆ¶åˆ°ä¸»ç”»å¸ƒ
                ctx.drawImage(
                    stampCanvas,
                    point.x - actualSize,
                    point.y - actualSize
                );

                ctx.restore();

                this.lastStamp = { point, size: actualSize };
            }

            smoothPoint(from, to) {
                if (this.strokeBuffer.length < 2) {
                    return to;
                }

                // ä½¿ç”¨è´å¡å°”æ›²çº¿å¹³æ»‘
                const smoothing = this.smoothing;
                return {
                    x: from.x + (to.x - from.x) * (1 - smoothing),
                    y: from.y + (to.y - from.y) * (1 - smoothing)
                };
            }

            adjustInputData(inputData) {
                // æ ¹æ®å„ç§è®¾ç½®è°ƒæ•´è¾“å…¥æ•°æ®
                const adjusted = { ...inputData };

                // é€Ÿåº¦å¹³æ»‘
                if (this.velocitySettings.smooth) {
                    adjusted.velocity = this.smoothVelocity(adjusted.velocity);
                }

                return adjusted;
            }

            smoothVelocity(velocity) {
                // å®ç°é€Ÿåº¦å¹³æ»‘ç®—æ³•
                if (!this.velocityHistory) {
                    this.velocityHistory = [];
                }

                this.velocityHistory.push(velocity);
                if (this.velocityHistory.length > 5) {
                    this.velocityHistory.shift();
                }

                return this.velocityHistory.reduce((a, b) => a + b) / this.velocityHistory.length;
            }

            applyWetEdges() {
                // å®ç°æ¹¿è¾¹æ•ˆæœ
                // è¿™é‡Œå¯ä»¥å®ç°æ°´å½©ç”»çš„è¾¹ç¼˜ç§¯ç´¯æ•ˆæœ
            }

            loadPreset(preset) {
                this.size = preset.size || 10;
                this.hardness = preset.hardness || 1;

                // æ›´æ–°UI
                document.getElementById('brushSizeSlider').value = this.size;
                document.getElementById('brushSizeValue').textContent = this.size + 'px';
                document.getElementById('brushHardnessSlider').value = this.hardness * 100;
                document.getElementById('brushHardnessValue').textContent = Math.round(this.hardness * 100) + '%';

                // åº”ç”¨é¢„è®¾ç‰¹æœ‰è®¾ç½®
                switch (preset.type) {
                    case 'watercolor':
                        this.wetness = 0.7;
                        this.bleedAmount = 0.3;
                        this.setTexture('watercolor');
                        break;
                    case 'oil':
                        this.wetness = 0.3;
                        this.setTexture('canvas');
                        break;
                    case 'pencil':
                        this.setTexture('paper');
                        this.pressureSettings.size = true;
                        this.pressureSettings.opacity = true;
                        break;
                    // ... å…¶ä»–é¢„è®¾
                }
            }

            setSize(size) {
                this.size = parseInt(size);
                this.app.updateCursor();
            }

            setHardness(hardness) {
                this.hardness = hardness;
            }

            setFlow(flow) {
                this.flow = flow;
            }

            setSpacing(spacing) {
                this.spacing = spacing;
            }

            increaseSize() {
                this.setSize(Math.min(500, this.size + 5));
                document.getElementById('brushSizeSlider').value = this.size;
                document.getElementById('brushSizeValue').textContent = this.size + 'px';
            }

            decreaseSize() {
                this.setSize(Math.max(1, this.size - 5));
                document.getElementById('brushSizeSlider').value = this.size;
                document.getElementById('brushSizeValue').textContent = this.size + 'px';
            }
        }

        // å›¾å±‚ç®¡ç†å™¨
        class LayerManager {
            constructor(app) {
                this.app = app;
                this.layers = [];
                this.activeLayerIndex = 0;

                // åˆ›å»ºé»˜è®¤å›¾å±‚
                this.addLayer('èƒŒæ™¯');
            }

            initUI() {
                // æ·»åŠ å›¾å±‚æŒ‰é’®
                document.getElementById('addLayerBtn').addEventListener('click', () => {
                    this.addLayer(`å›¾å±‚ ${this.layers.length + 1}`);
                });

                // æ··åˆæ¨¡å¼
                document.getElementById('blendModeSelect').addEventListener('change', (e) => {
                    this.setBlendMode(e.target.value);
                });

                // ä¸é€æ˜åº¦
                document.getElementById('layerOpacitySlider').addEventListener('input', (e) => {
                    this.setOpacity(e.target.value / 100);
                    document.getElementById('layerOpacityValue').textContent = e.target.value + '%';
                });

                this.updateLayersPanel();
            }

            addLayer(name) {
                const canvas = document.createElement('canvas');
                canvas.width = this.app.canvas.width;
                canvas.height = this.app.canvas.height;

                const layer = {
                    id: Date.now(),
                    name: name,
                    canvas: canvas,
                    ctx: canvas.getContext('2d'),
                    visible: true,
                    opacity: 1,
                    blendMode: 'normal',
                    locked: false
                };

                this.layers.push(layer);
                this.activeLayerIndex = this.layers.length - 1;
                this.updateLayersPanel();

                return layer;
            }

            removeLayer(index) {
                if (this.layers.length > 1) {
                    this.layers.splice(index, 1);
                    this.activeLayerIndex = Math.min(this.activeLayerIndex, this.layers.length - 1);
                    this.updateLayersPanel();
                }
            }

            duplicateLayer(index) {
                const source = this.layers[index];
                const newLayer = this.addLayer(source.name + ' å‰¯æœ¬');

                // å¤åˆ¶ç”»å¸ƒå†…å®¹
                newLayer.ctx.drawImage(source.canvas, 0, 0);

                this.updateLayersPanel();
            }

            mergeDown(index) {
                if (index > 0) {
                    const upper = this.layers[index];
                    const lower = this.layers[index - 1];

                    // åˆå¹¶å›¾å±‚
                    lower.ctx.save();
                    lower.ctx.globalAlpha = upper.opacity;
                    lower.ctx.globalCompositeOperation = upper.blendMode;
                    lower.ctx.drawImage(upper.canvas, 0, 0);
                    lower.ctx.restore();

                    // åˆ é™¤ä¸Šå±‚
                    this.removeLayer(index);
                }
            }

            setBlendMode(mode) {
                const layer = this.layers[this.activeLayerIndex];
                if (layer) {
                    layer.blendMode = mode;
                    this.renderComposite();
                }
            }

            setOpacity(opacity) {
                const layer = this.layers[this.activeLayerIndex];
                if (layer) {
                    layer.opacity = opacity;
                    this.renderComposite();
                }
            }

            toggleVisibility(index) {
                this.layers[index].visible = !this.layers[index].visible;
                this.renderComposite();
            }

            toggleLock(index) {
                this.layers[index].locked = !this.layers[index].locked;
                this.updateLayersPanel();
            }

            selectLayer(index) {
                this.activeLayerIndex = index;
                this.updateLayersPanel();

                // åˆ‡æ¢ç»˜åˆ¶ä¸Šä¸‹æ–‡åˆ°å½“å‰å›¾å±‚
                this.app.ctx = this.layers[index].ctx;
            }

            updateLayersPanel() {
                const panel = document.getElementById('layersPanel');
                panel.innerHTML = '';

                // ä»ä¸Šåˆ°ä¸‹æ˜¾ç¤ºå›¾å±‚ï¼ˆæ•°ç»„åå‘ï¼‰
                [...this.layers].reverse().forEach((layer, reverseIndex) => {
                    const index = this.layers.length - 1 - reverseIndex;
                    const div = document.createElement('div');
                    div.className = 'layer-item';
                    if (index === this.activeLayerIndex) {
                        div.classList.add('active');
                    }

                    // ç¼©ç•¥å›¾
                    const thumbnail = document.createElement('canvas');
                    thumbnail.className = 'layer-thumbnail';
                    thumbnail.width = 40;
                    thumbnail.height = 40;
                    const thumbCtx = thumbnail.getContext('2d');
                    thumbCtx.drawImage(layer.canvas, 0, 0, 40, 40);

                    // å›¾å±‚ä¿¡æ¯
                    const info = document.createElement('div');
                    info.className = 'layer-info';
                    info.innerHTML = `
                        <div class="layer-name">${layer.name}</div>
                        <div class="layer-opacity">${Math.round(layer.opacity * 100)}%</div>
                    `;

                    // æ§åˆ¶æŒ‰é’®
                    const controls = document.createElement('div');
                    controls.className = 'layer-controls';

                    const visBtn = document.createElement('button');
                    visBtn.className = 'layer-control-btn';
                    visBtn.innerHTML = layer.visible ? 'ğŸ‘ï¸' : 'ğŸ‘ï¸â€ğŸ—¨ï¸';
                    visBtn.onclick = () => this.toggleVisibility(index);

                    const lockBtn = document.createElement('button');
                    lockBtn.className = 'layer-control-btn';
                    lockBtn.innerHTML = layer.locked ? 'ğŸ”’' : 'ğŸ”“';
                    lockBtn.onclick = () => this.toggleLock(index);

                    controls.appendChild(visBtn);
                    controls.appendChild(lockBtn);

                    div.appendChild(thumbnail);
                    div.appendChild(info);
                    div.appendChild(controls);

                    div.onclick = (e) => {
                        if (!e.target.classList.contains('layer-control-btn')) {
                            this.selectLayer(index);
                        }
                    };

                    panel.appendChild(div);
                });

                // æ›´æ–°å›¾å±‚æ•°é‡æ˜¾ç¤º
                document.getElementById('layerCount').textContent = this.layers.length;
            }

            updateThumbnails() {
                // æ›´æ–°æ‰€æœ‰å›¾å±‚ç¼©ç•¥å›¾
                this.updateLayersPanel();
            }

            renderComposite() {
                // åˆæˆæ‰€æœ‰å¯è§å›¾å±‚åˆ°ä¸»ç”»å¸ƒ
                const mainCtx = this.app.canvas.getContext('2d');
                mainCtx.clearRect(0, 0, this.app.canvas.width, this.app.canvas.height);

                this.layers.forEach(layer => {
                    if (layer.visible) {
                        mainCtx.save();
                        mainCtx.globalAlpha = layer.opacity;
                        mainCtx.globalCompositeOperation = layer.blendMode;
                        mainCtx.drawImage(layer.canvas, 0, 0);
                        mainCtx.restore();
                    }
                });
            }

            renderAllLayers(ctx) {
                // æ¸²æŸ“æ‰€æœ‰å›¾å±‚åˆ°æŒ‡å®šä¸Šä¸‹æ–‡ï¼ˆç”¨äºå¯¼å‡ºï¼‰
                this.layers.forEach(layer => {
                    if (layer.visible) {
                        ctx.save();
                        ctx.globalAlpha = layer.opacity;
                        ctx.globalCompositeOperation = layer.blendMode;
                        ctx.drawImage(layer.canvas, 0, 0);
                        ctx.restore();
                    }
                });
            }

            clear() {
                this.layers = [];
                this.addLayer('èƒŒæ™¯');
                this.updateLayersPanel();
            }

            exportLayers() {
                // å¯¼å‡ºå›¾å±‚æ•°æ®
                return this.layers.map(layer => ({
                    name: layer.name,
                    visible: layer.visible,
                    opacity: layer.opacity,
                    blendMode: layer.blendMode,
                    locked: layer.locked,
                    data: layer.canvas.toDataURL()
                }));
            }
        }

        // é¢œè‰²ç³»ç»Ÿ
        class ColorSystem {
            constructor(app) {
                this.app = app;
                this.currentColor = { r: 255, g: 107, b: 107 };
                this.colorMode = 'rgb';
                this.recentColors = [];
                this.palette = [];

                this.initColorWheel();
            }

            initUI() {
                // é¢œè‰²æ¨¡å¼åˆ‡æ¢
                document.querySelectorAll('.color-mode-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        this.setColorMode(tab.dataset.mode);
                        document.querySelectorAll('.color-mode-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                    });
                });

                // RGBè¾“å…¥
                ['R', 'G', 'B'].forEach(channel => {
                    document.getElementById(`color${channel}`).addEventListener('input', (e) => {
                        this.currentColor[channel.toLowerCase()] = parseInt(e.target.value);
                        this.updateColorDisplay();
                    });
                });

                // åˆå§‹åŒ–æœ€è¿‘é¢œè‰²å’Œè‰²æ¿
                this.updateRecentColors();
                this.loadDefaultPalette();
            }

            initColorWheel() {
                const canvas = document.getElementById('colorWheel');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 200;

                // ç»˜åˆ¶è‰²è½®
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = 90;

                for (let angle = 0; angle < 360; angle += 1) {
                    const startAngle = (angle - 1) * Math.PI / 180;
                    const endAngle = angle * Math.PI / 180;

                    for (let r = 0; r < radius; r += 1) {
                        const saturation = r / radius;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, r, startAngle, endAngle);
                        ctx.strokeStyle = `hsl(${angle}, ${saturation * 100}%, 50%)`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }

                // è‰²è½®äº¤äº’
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left - centerX;
                    const y = e.clientY - rect.top - centerY;

                    const angle = Math.atan2(y, x) * 180 / Math.PI + 180;
                    const distance = Math.sqrt(x * x + y * y);
                    const saturation = Math.min(distance / radius, 1);

                    this.setHSL(angle, saturation, 0.5);
                });
            }

            setColorMode(mode) {
                this.colorMode = mode;
                this.updateColorInputs();
            }

            updateColorInputs() {
                // æ ¹æ®é¢œè‰²æ¨¡å¼æ›´æ–°è¾“å…¥æ¡†
                // è¿™é‡Œå¯ä»¥æ ¹æ®ä¸åŒæ¨¡å¼æ˜¾ç¤ºä¸åŒçš„è¾“å…¥æ¡†
            }

            setHSL(h, s, l) {
                // HSLè½¬RGB
                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = l - c / 2;

                let r, g, b;
                if (h < 60) {
                    [r, g, b] = [c, x, 0];
                } else if (h < 120) {
                    [r, g, b] = [x, c, 0];
                } else if (h < 180) {
                    [r, g, b] = [0, c, x];
                } else if (h < 240) {
                    [r, g, b] = [0, x, c];
                } else if (h < 300) {
                    [r, g, b] = [x, 0, c];
                } else {
                    [r, g, b] = [c, 0, x];
                }

                this.currentColor = {
                    r: Math.round((r + m) * 255),
                    g: Math.round((g + m) * 255),
                    b: Math.round((b + m) * 255)
                };

                this.updateColorDisplay();
            }

            updateColorDisplay() {
                // æ›´æ–°é¢œè‰²æ˜¾ç¤º
                document.getElementById('colorR').value = this.currentColor.r;
                document.getElementById('colorG').value = this.currentColor.g;
                document.getElementById('colorB').value = this.currentColor.b;

                // æ·»åŠ åˆ°æœ€è¿‘ä½¿ç”¨
                this.addToRecentColors(this.currentColor);
            }

            addToRecentColors(color) {
                const colorStr = `rgb(${color.r},${color.g},${color.b})`;

                // ç§»é™¤é‡å¤çš„
                this.recentColors = this.recentColors.filter(c => c !== colorStr);

                // æ·»åŠ åˆ°å¼€å¤´
                this.recentColors.unshift(colorStr);

                // é™åˆ¶æ•°é‡
                if (this.recentColors.length > 16) {
                    this.recentColors.pop();
                }

                this.updateRecentColors();
            }

            updateRecentColors() {
                const container = document.getElementById('recentColors');
                container.innerHTML = '';

                this.recentColors.forEach(color => {
                    const div = document.createElement('div');
                    div.style.width = '20px';
                    div.style.height = '20px';
                    div.style.backgroundColor = color;
                    div.style.border = '1px solid #dee2e6';
                    div.style.borderRadius = '4px';
                    div.style.cursor = 'pointer';

                    div.onclick = () => {
                        const rgb = color.match(/\d+/g);
                        this.currentColor = {
                            r: parseInt(rgb[0]),
                            g: parseInt(rgb[1]),
                            b: parseInt(rgb[2])
                        };
                        this.updateColorDisplay();
                    };

                    container.appendChild(div);
                });
            }

            loadDefaultPalette() {
                // åŠ è½½é»˜è®¤è‰²æ¿
                const defaultColors = [
                    '#000000', '#FFFFFF', '#FF0000', '#00FF00',
                    '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
                    '#800000', '#008000', '#000080', '#808000',
                    '#800080', '#008080', '#C0C0C0', '#808080'
                ];

                const container = document.getElementById('colorPalette');
                container.innerHTML = '';

                defaultColors.forEach(color => {
                    const div = document.createElement('div');
                    div.style.width = '20px';
                    div.style.height = '20px';
                    div.style.backgroundColor = color;
                    div.style.border = '1px solid #dee2e6';
                    div.style.borderRadius = '4px';
                    div.style.cursor = 'pointer';

                    div.onclick = () => {
                        const hex = color.substring(1);
                        this.currentColor = {
                            r: parseInt(hex.substring(0, 2), 16),
                            g: parseInt(hex.substring(2, 4), 16),
                            b: parseInt(hex.substring(4, 6), 16)
                        };
                        this.updateColorDisplay();
                    };

                    container.appendChild(div);
                });
            }

            pickColor(point) {
                // ä»ç”»å¸ƒæ‹¾å–é¢œè‰²
                const imageData = this.app.ctx.getImageData(point.x, point.y, 1, 1);
                const data = imageData.data;

                this.currentColor = {
                    r: data[0],
                    g: data[1],
                    b: data[2]
                };

                this.updateColorDisplay();
            }

            getCurrentColor() {
                return this.currentColor;
            }
        }

        // å†å²ç®¡ç†å™¨
        class HistoryManager {
            constructor(app) {
                this.app = app;
                this.history = [];
                this.currentIndex = -1;
                this.maxHistory = Infinity;  // æ— é™å†å²è®°å½•
            }

            initUI() {
                // æ’¤é”€/é‡åšæŒ‰é’®
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('redoBtn').addEventListener('click', () => this.redo());

                this.updateUI();
            }

            saveState() {
                // ä¿å­˜å½“å‰çŠ¶æ€
                const state = {
                    timestamp: Date.now(),
                    action: this.getCurrentAction(),
                    layers: this.app.layerManager.exportLayers(),
                    thumbnail: this.createThumbnail()
                };

                // å¦‚æœä¸åœ¨å†å²æœ«å°¾ï¼Œåˆ é™¤åé¢çš„å†å²
                if (this.currentIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.currentIndex + 1);
                }

                // æ·»åŠ æ–°çŠ¶æ€
                this.history.push(state);
                this.currentIndex++;

                // é™åˆ¶å†å²æ•°é‡ï¼ˆå¦‚æœéœ€è¦ï¼‰
                if (this.maxHistory !== Infinity && this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.currentIndex--;
                }

                this.updateUI();
                this.updateTimeline();
            }

            undo() {
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.restoreState(this.history[this.currentIndex]);
                    this.updateUI();
                    this.updateTimeline();
                }
            }

            redo() {
                if (this.currentIndex < this.history.length - 1) {
                    this.currentIndex++;
                    this.restoreState(this.history[this.currentIndex]);
                    this.updateUI();
                    this.updateTimeline();
                }
            }

            restoreState(state) {
                // æ¢å¤çŠ¶æ€
                // è¿™é‡Œéœ€è¦æ¢å¤å›¾å±‚æ•°æ®
                console.log('æ¢å¤çŠ¶æ€:', state.action);
            }

            getCurrentAction() {
                // è·å–å½“å‰æ“ä½œæè¿°
                const tool = this.app.currentTool;
                const actions = {
                    'brush': 'ç”»ç¬”ç»˜åˆ¶',
                    'eraser': 'æ“¦é™¤',
                    'fill': 'å¡«å……',
                    'text': 'æ·»åŠ æ–‡å­—',
                    // ...
                };
                return actions[tool] || 'æ“ä½œ';
            }

            createThumbnail() {
                // åˆ›å»ºç¼©ç•¥å›¾
                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = 30;
                thumbCanvas.height = 30;
                const ctx = thumbCanvas.getContext('2d');
                ctx.drawImage(this.app.canvas, 0, 0, 30, 30);
                return thumbCanvas.toDataURL();
            }

            updateUI() {
                // æ›´æ–°æ’¤é”€/é‡åšæŒ‰é’®çŠ¶æ€
                document.getElementById('undoBtn').disabled = this.currentIndex <= 0;
                document.getElementById('redoBtn').disabled = this.currentIndex >= this.history.length - 1;

                // æ›´æ–°å†å²è®¡æ•°
                document.getElementById('historyCount').textContent =
                    `${this.currentIndex + 1}/${this.maxHistory === Infinity ? 'âˆ' : this.maxHistory}`;
            }

            updateTimeline() {
                // æ›´æ–°å†å²æ—¶é—´è½´
                const timeline = document.getElementById('historyTimeline');
                timeline.innerHTML = '';

                // æ˜¾ç¤ºæœ€è¿‘çš„å†å²è®°å½•
                const start = Math.max(0, this.currentIndex - 5);
                const end = Math.min(this.history.length, this.currentIndex + 6);

                for (let i = start; i < end; i++) {
                    const state = this.history[i];
                    const div = document.createElement('div');
                    div.className = 'history-item';
                    if (i === this.currentIndex) {
                        div.classList.add('current');
                    }

                    const thumb = document.createElement('img');
                    thumb.className = 'history-thumbnail';
                    thumb.src = state.thumbnail;

                    const info = document.createElement('div');
                    info.className = 'history-info';
                    info.innerHTML = `
                        <div class="history-action">${state.action}</div>
                        <div class="history-time">${this.formatTime(state.timestamp)}</div>
                    `;

                    div.appendChild(thumb);
                    div.appendChild(info);

                    div.onclick = () => {
                        this.currentIndex = i;
                        this.restoreState(state);
                        this.updateUI();
                        this.updateTimeline();
                    };

                    timeline.appendChild(div);
                }
            }

            formatTime(timestamp) {
                const date = new Date(timestamp);
                return date.toLocaleTimeString('zh-CN', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            }

            clear() {
                this.history = [];
                this.currentIndex = -1;
                this.updateUI();
                this.updateTimeline();
            }

            exportHistory() {
                return this.history.map(state => ({
                    timestamp: state.timestamp,
                    action: state.action
                }));
            }
        }

        // å¯¹ç§°å·¥å…·
        class SymmetryTool {
            constructor(app) {
                this.app = app;
                this.mode = 'none';
                this.segments = 4;
                this.center = { x: 960, y: 540 };
            }

            setMode(mode) {
                this.mode = mode;
                this.updateOverlay();
            }

            setSegments(segments) {
                this.segments = segments;
                this.updateOverlay();
            }

            updateOverlay() {
                // æ›´æ–°å¯¹ç§°è¾…åŠ©çº¿æ˜¾ç¤º
                // ...
            }

            applySymmetry(point, callback) {
                switch (this.mode) {
                    case 'horizontal':
                        callback(point);
                        callback({ x: this.center.x * 2 - point.x, y: point.y });
                        break;
                    case 'vertical':
                        callback(point);
                        callback({ x: point.x, y: this.center.y * 2 - point.y });
                        break;
                    case 'radial':
                        for (let i = 0; i < this.segments; i++) {
                            const angle = (Math.PI * 2 / this.segments) * i;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);

                            const dx = point.x - this.center.x;
                            const dy = point.y - this.center.y;

                            const newX = this.center.x + dx * cos - dy * sin;
                            const newY = this.center.y + dx * sin + dy * cos;

                            callback({ x: newX, y: newY });
                        }
                        break;
                    case 'kaleidoscope':
                        // ä¸‡èŠ±ç­’æ¨¡å¼
                        for (let i = 0; i < this.segments; i++) {
                            const angle = (Math.PI * 2 / this.segments) * i;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);

                            const dx = point.x - this.center.x;
                            const dy = point.y - this.center.y;

                            // æ—‹è½¬
                            const rotX = this.center.x + dx * cos - dy * sin;
                            const rotY = this.center.y + dx * sin + dy * cos;
                            callback({ x: rotX, y: rotY });

                            // é•œåƒ
                            const mirrorX = this.center.x + dx * cos + dy * sin;
                            const mirrorY = this.center.y - dx * sin + dy * cos;
                            callback({ x: mirrorX, y: mirrorY });
                        }
                        break;
                    default:
                        callback(point);
                }
            }
        }

        // é€è§†å·¥å…·
        class PerspectiveTool {
            constructor(app) {
                this.app = app;
                this.points = 1;
                this.vanishingPoints = [];
                this.gridDensity = 10;
                this.snapEnabled = true;
            }

            setPoints(points) {
                this.points = points;
                this.setupVanishingPoints();
                this.drawGrid();
            }

            setupVanishingPoints() {
                // è®¾ç½®ç­ç‚¹ä½ç½®
                switch (this.points) {
                    case 1:
                        this.vanishingPoints = [
                            { x: this.app.canvas.width / 2, y: this.app.canvas.height / 2 }
                        ];
                        break;
                    case 2:
                        this.vanishingPoints = [
                            { x: this.app.canvas.width * 0.2, y: this.app.canvas.height / 2 },
                            { x: this.app.canvas.width * 0.8, y: this.app.canvas.height / 2 }
                        ];
                        break;
                    case 3:
                        this.vanishingPoints = [
                            { x: this.app.canvas.width * 0.2, y: this.app.canvas.height / 2 },
                            { x: this.app.canvas.width * 0.8, y: this.app.canvas.height / 2 },
                            { x: this.app.canvas.width / 2, y: this.app.canvas.height * 0.1 }
                        ];
                        break;
                }
            }

            drawGrid() {
                const overlay = document.getElementById('perspectiveOverlay');
                const ctx = overlay.getContext('2d');

                overlay.width = this.app.canvas.width;
                overlay.height = this.app.canvas.height;

                ctx.clearRect(0, 0, overlay.width, overlay.height);
                ctx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                ctx.lineWidth = 1;

                // ç»˜åˆ¶é€è§†ç½‘æ ¼
                this.vanishingPoints.forEach(vp => {
                    // ä»ç­ç‚¹å‘å‡ºçš„å°„çº¿
                    for (let i = 0; i <= this.gridDensity; i++) {
                        const angle = (Math.PI * 2 / this.gridDensity) * i;
                        const endX = vp.x + Math.cos(angle) * 2000;
                        const endY = vp.y + Math.sin(angle) * 2000;

                        ctx.beginPath();
                        ctx.moveTo(vp.x, vp.y);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }
                });
            }

            snapToGrid(point) {
                if (!this.snapEnabled) {
                    return point;
                }

                // å¸é™„åˆ°æœ€è¿‘çš„é€è§†çº¿
                // ... å®ç°å¸é™„ç®—æ³•

                return point;
            }
        }

        // å˜æ¢å·¥å…·
        class TransformTool {
            constructor(app) {
                this.app = app;
                this.selection = null;
                this.transformMatrix = [1, 0, 0, 1, 0, 0];
            }

            startTransform(selection) {
                this.selection = selection;
                // æ˜¾ç¤ºå˜æ¢æ§åˆ¶ç‚¹
            }

            applyTransform(matrix) {
                // åº”ç”¨å˜æ¢çŸ©é˜µ
                this.transformMatrix = matrix;
                this.redrawSelection();
            }

            redrawSelection() {
                // é‡ç»˜é€‰åŒºå†…å®¹
            }
        }

        // æ€§èƒ½ç›‘è§†å™¨
        class PerformanceMonitor {
            constructor() {
                this.fps = 60;
                this.memory = 0;
                this.lastTime = performance.now();
                this.frames = 0;

                // å¼€å§‹ç›‘æ§
                this.startMonitoring();
            }

            startMonitoring() {
                setInterval(() => {
                    const now = performance.now();
                    const delta = now - this.lastTime;

                    this.fps = Math.round((this.frames * 1000) / delta);
                    this.frames = 0;
                    this.lastTime = now;

                    // å†…å­˜ä½¿ç”¨ï¼ˆå¦‚æœæ”¯æŒï¼‰
                    if (performance.memory) {
                        this.memory = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    }

                    this.updateDisplay();
                }, 1000);

                // å¸§è®¡æ•°
                const countFrame = () => {
                    this.frames++;
                    requestAnimationFrame(countFrame);
                };
                countFrame();
            }

            updateDisplay() {
                document.getElementById('fps').textContent = this.fps;
                document.getElementById('memory').textContent = this.memory;
            }
        }

        // äº‘ç«¯åŒæ­¥ï¼ˆæ¨¡æ‹Ÿï¼‰
        class CloudSync {
            constructor() {
                this.syncing = false;
                this.lastSync = Date.now();
            }

            async sync() {
                this.showSyncStatus('åŒæ­¥ä¸­...');
                this.syncing = true;

                // æ¨¡æ‹ŸåŒæ­¥å»¶è¿Ÿ
                await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));

                this.syncing = false;
                this.lastSync = Date.now();
                this.showSyncStatus('å·²åŒæ­¥');

                setTimeout(() => {
                    this.hideSyncStatus();
                }, 2000);
            }

            showSyncStatus(message) {
                const status = document.getElementById('syncStatus');
                document.getElementById('syncMessage').textContent = message;
                status.classList.add('show');
            }

            hideSyncStatus() {
                const status = document.getElementById('syncStatus');
                status.classList.remove('show');
            }

            autoSync() {
                setInterval(() => {
                    if (!this.syncing && Date.now() - this.lastSync > 30000) {
                        this.sync();
                    }
                }, 5000);
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        window.addEventListener('DOMContentLoaded', () => {
            const app = new DrawingApp();
            window.drawingApp = app;  // æš´éœ²ç»™å…¨å±€ï¼ˆç”¨äºè°ƒè¯•ï¼‰
        });
    </script>
</body>
</html>