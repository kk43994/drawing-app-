<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Â∞èÊñ∞ÁîªÁîªÊùø Pro - ‰∏ì‰∏öÁâà üé®</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #FF6B6B;
            --secondary-color: #4ECDC4;
            --accent-color: #FFE66D;
            --dark-bg: #2C3E50;
            --light-bg: #ECF0F1;
            --panel-bg: rgba(255, 255, 255, 0.95);
            --shadow: 0 4px 20px rgba(0,0,0,0.1);
            --radius: 12px;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            overflow: hidden;
            touch-action: none;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100%;
        }

        /* È°∂ÈÉ®Â∑•ÂÖ∑Ê†è */
        .top-toolbar {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--panel-bg);
            backdrop-filter: blur(10px);
            box-shadow: var(--shadow);
            display: flex;
            align-items: center;
            padding: 0 20px;
            z-index: 1000;
            gap: 20px;
        }

        .logo {
            font-size: 24px;
            font-weight: bold;
            background: linear-gradient(135deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tool-section {
            display: flex;
            gap: 10px;
            align-items: center;
            padding: 0 15px;
            border-left: 1px solid rgba(0,0,0,0.1);
        }

        .tool-section:first-child {
            border-left: none;
        }

        /* Â∑¶‰æßÂ∑•ÂÖ∑Èù¢Êùø */
        .left-panel {
            position: fixed;
            left: 0;
            top: 60px;
            bottom: 0;
            width: 80px;
            background: var(--panel-bg);
            box-shadow: var(--shadow);
            display: flex;
            flex-direction: column;
            gap: 10px;
            padding: 20px 10px;
            z-index: 999;
            overflow-y: auto;
        }

        .tool-btn {
            width: 60px;
            height: 60px;
            border: 2px solid transparent;
            border-radius: var(--radius);
            background: white;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 4px;
            transition: all 0.3s ease;
            position: relative;
        }

        .tool-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(0,0,0,0.15);
            border-color: var(--primary-color);
        }

        .tool-btn.active {
            background: linear-gradient(135deg, #667eea, #764ba2);
            color: white;
            border-color: transparent;
        }

        .tool-btn .icon {
            font-size: 24px;
        }

        .tool-btn .label {
            font-size: 10px;
            font-weight: 600;
        }

        /* Âè≥‰æßÂ±ûÊÄßÈù¢Êùø */
        .right-panel {
            position: fixed;
            right: 0;
            top: 60px;
            bottom: 0;
            width: 280px;
            background: var(--panel-bg);
            box-shadow: var(--shadow);
            z-index: 999;
            overflow-y: auto;
            padding: 20px;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .panel-section {
            background: white;
            border-radius: var(--radius);
            padding: 15px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }

        .panel-title {
            font-size: 14px;
            font-weight: 600;
            color: #333;
            margin-bottom: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        /* ÁîªÂ∏ÉÂÆπÂô® */
        .canvas-container {
            position: fixed;
            left: 80px;
            right: 280px;
            top: 60px;
            bottom: 0;
            overflow: hidden;
            background: #f5f5f5;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .canvas-viewport {
            position: relative;
            background: white;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            border-radius: 4px;
            transform-origin: center center;
        }

        #mainCanvas {
            display: block;
            cursor: crosshair;
        }

        /* ÂõæÂ±ÇÈù¢Êùø */
        .layers-panel {
            max-height: 300px;
            overflow-y: auto;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 5px;
            cursor: pointer;
            transition: all 0.2s;
        }

        .layer-item:hover {
            background: #e9ecef;
        }

        .layer-item.active {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border: 1px solid #667eea;
        }

        .layer-thumbnail {
            width: 40px;
            height: 40px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: white;
        }

        .layer-info {
            flex: 1;
        }

        .layer-name {
            font-size: 12px;
            font-weight: 500;
            color: #333;
        }

        .layer-opacity {
            font-size: 10px;
            color: #6c757d;
        }

        .layer-controls {
            display: flex;
            gap: 5px;
        }

        .layer-control-btn {
            width: 24px;
            height: 24px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: background 0.2s;
        }

        .layer-control-btn:hover {
            background: rgba(0,0,0,0.05);
        }

        /* Á¨îÂà∑È¢ÑËÆæ */
        .brush-presets {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }

        .brush-preset {
            aspect-ratio: 1;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            background: white;
            position: relative;
            overflow: hidden;
            transition: all 0.2s;
        }

        .brush-preset:hover {
            border-color: var(--primary-color);
            transform: scale(1.05);
        }

        .brush-preset.active {
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.2);
        }

        .brush-preset canvas {
            width: 100%;
            height: 100%;
        }

        /* Ëâ≤ÂΩ©ÈÄâÊã©Âô® */
        .color-picker-advanced {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .color-mode-tabs {
            display: flex;
            gap: 5px;
            background: #f1f3f4;
            padding: 3px;
            border-radius: 8px;
        }

        .color-mode-tab {
            flex: 1;
            padding: 6px;
            border: none;
            background: transparent;
            cursor: pointer;
            border-radius: 6px;
            font-size: 12px;
            font-weight: 500;
            transition: all 0.2s;
        }

        .color-mode-tab.active {
            background: white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }

        .color-wheel {
            width: 100%;
            height: 200px;
            border-radius: 50%;
            position: relative;
            margin: 10px auto;
        }

        .color-slider {
            width: 100%;
            margin: 8px 0;
        }

        .color-input-group {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .color-input {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .color-input label {
            font-size: 10px;
            color: #6c757d;
            font-weight: 500;
        }

        .color-input input {
            padding: 4px 8px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            font-size: 12px;
        }

        /* Á¨îÂà∑ÂèÇÊï∞ÊéßÂà∂ */
        .brush-controls {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 6px;
        }

        .control-label {
            font-size: 11px;
            color: #6c757d;
            font-weight: 500;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .control-value {
            font-size: 11px;
            color: #333;
            font-weight: 600;
        }

        .slider {
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #e9ecef;
            outline: none;
            transition: background 0.3s;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .slider::-moz-range-thumb {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea, #764ba2);
            cursor: pointer;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        /* ÂØπÁß∞Ê®°ÂºèÊéßÂà∂ */
        .symmetry-controls {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
        }

        .symmetry-mode {
            padding: 8px;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            background: white;
        }

        .symmetry-mode:hover {
            border-color: var(--primary-color);
        }

        .symmetry-mode.active {
            border-color: #667eea;
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
        }

        .symmetry-mode .icon {
            font-size: 20px;
            margin-bottom: 4px;
        }

        .symmetry-mode .name {
            font-size: 10px;
            color: #6c757d;
        }

        /* ÊµÆÂä®Â∑•ÂÖ∑ÊèêÁ§∫ */
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 6px 12px;
            border-radius: 6px;
            font-size: 12px;
            pointer-events: none;
            z-index: 10000;
            opacity: 0;
            transition: opacity 0.2s;
        }

        .tooltip.show {
            opacity: 1;
        }

        /* Âø´Êç∑ÈîÆÊèêÁ§∫ */
        .shortcut-hint {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 12px;
            display: none;
            z-index: 1000;
        }

        .shortcut-hint.show {
            display: block;
            animation: fadeInUp 0.3s ease;
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Âä†ËΩΩÂä®Áîª */
        .loader {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            display: none;
            z-index: 10000;
        }

        .loader.show {
            display: block;
        }

        .loader-spinner {
            width: 50px;
            height: 50px;
            border: 4px solid rgba(102, 126, 234, 0.3);
            border-top-color: #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* ÂìçÂ∫îÂºèËÆæËÆ° */
        @media (max-width: 1024px) {
            .right-panel {
                width: 240px;
            }

            .left-panel {
                width: 60px;
            }

            .tool-btn {
                width: 50px;
                height: 50px;
            }

            .tool-btn .icon {
                font-size: 20px;
            }

            .tool-btn .label {
                display: none;
            }
        }

        @media (max-width: 768px) {
            .right-panel {
                position: fixed;
                right: -280px;
                transition: right 0.3s;
            }

            .right-panel.open {
                right: 0;
            }

            .canvas-container {
                right: 0;
            }
        }

        /* È´òÁ∫ßÊ∑∑ÂêàÊ®°ÂºèÈÄâÊã©Âô® */
        .blend-mode-selector {
            width: 100%;
            padding: 8px;
            border: 1px solid #dee2e6;
            border-radius: 6px;
            font-size: 12px;
            background: white;
            cursor: pointer;
        }

        /* Ê∏êÂèòÁºñËæëÂô® */
        .gradient-editor {
            padding: 15px;
            background: white;
            border-radius: 8px;
            margin-top: 10px;
        }

        .gradient-preview {
            height: 40px;
            border-radius: 6px;
            margin-bottom: 15px;
            border: 1px solid #dee2e6;
        }

        .gradient-stops {
            position: relative;
            height: 20px;
            margin: 10px 0;
            border-radius: 10px;
            background: linear-gradient(to right, #000, #fff);
            cursor: pointer;
        }

        .gradient-stop {
            position: absolute;
            width: 12px;
            height: 12px;
            border: 2px solid white;
            border-radius: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
            cursor: grab;
            box-shadow: 0 2px 4px rgba(0,0,0,0.2);
        }

        .gradient-stop.active {
            width: 16px;
            height: 16px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        /* ÈÄèËßÜÁΩëÊ†ºË¶ÜÁõñÂ±Ç */
        .perspective-overlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 100;
        }

        /* ÂèÇËÄÉÂõæÁâáÁ™óÂè£ */
        .reference-window {
            position: fixed;
            width: 300px;
            height: 300px;
            background: white;
            border-radius: 8px;
            box-shadow: 0 10px 40px rgba(0,0,0,0.2);
            z-index: 1000;
            display: none;
        }

        .reference-window.active {
            display: block;
        }

        .reference-header {
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px 8px 0 0;
            cursor: move;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .reference-content {
            padding: 10px;
            height: calc(100% - 40px);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .reference-content img {
            max-width: 100%;
            max-height: 100%;
            object-fit: contain;
        }

        /* ÂéÜÂè≤ËÆ∞ÂΩïÊó∂Èó¥ËΩ¥ */
        .history-timeline {
            display: flex;
            flex-direction: column;
            gap: 5px;
            max-height: 200px;
            overflow-y: auto;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .history-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 8px;
            background: white;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 12px;
        }

        .history-item:hover {
            background: #e9ecef;
        }

        .history-item.current {
            background: linear-gradient(135deg, rgba(102, 126, 234, 0.1), rgba(118, 75, 162, 0.1));
            border-left: 3px solid #667eea;
        }

        .history-thumbnail {
            width: 30px;
            height: 30px;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            background: white;
        }

        .history-info {
            flex: 1;
        }

        .history-action {
            font-weight: 500;
            color: #333;
        }

        .history-time {
            font-size: 10px;
            color: #6c757d;
        }

        /* Ëá™ÂÆö‰πâÂÖâÊ†á */
        .custom-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            mix-blend-mode: difference;
        }

        .cursor-ring {
            border: 2px solid rgba(102, 126, 234, 0.6);
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
        }

        /* ÊÄßËÉΩÁõëËßÜÂô® */
        .performance-monitor {
            position: fixed;
            bottom: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: #0f0;
            font-family: monospace;
            font-size: 10px;
            padding: 5px;
            border-radius: 4px;
            display: none;
            z-index: 10000;
        }

        .performance-monitor.show {
            display: block;
        }

        /* ‰∫ëÁ´ØÂêåÊ≠•Áä∂ÊÄÅ */
        .sync-status {
            position: fixed;
            top: 70px;
            right: 20px;
            background: white;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 12px;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            opacity: 0;
            transform: translateY(-10px);
            transition: all 0.3s;
        }

        .sync-status.show {
            opacity: 1;
            transform: translateY(0);
        }

        .sync-icon {
            width: 16px;
            height: 16px;
            animation: rotate 2s linear infinite;
        }

        @keyframes rotate {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- È°∂ÈÉ®Â∑•ÂÖ∑Ê†è -->
    <div class="top-toolbar">
        <div class="logo">
            <span>üé®</span>
            <span>Â∞èÊñ∞ÁîªÁîªÊùø Pro</span>
        </div>

        <div class="tool-section">
            <button class="tool-action" id="newFileBtn" title="Êñ∞Âª∫ (Ctrl+N)">üìÑ Êñ∞Âª∫</button>
            <button class="tool-action" id="openFileBtn" title="ÊâìÂºÄ (Ctrl+O)">üìÅ ÊâìÂºÄ</button>
            <button class="tool-action" id="saveFileBtn" title="‰øùÂ≠ò (Ctrl+S)">üíæ ‰øùÂ≠ò</button>
            <button class="tool-action" id="exportBtn" title="ÂØºÂá∫">üì§ ÂØºÂá∫</button>
        </div>

        <div class="tool-section">
            <button class="tool-action" id="undoBtn" title="Êí§ÈîÄ (Ctrl+Z)">‚Ü∂</button>
            <button class="tool-action" id="redoBtn" title="ÈáçÂÅö (Ctrl+Y)">‚Ü∑</button>
            <span class="history-count">ÂéÜÂè≤: <span id="historyCount">0/‚àû</span></span>
        </div>

        <div class="tool-section">
            <label>Áº©Êîæ: <span id="zoomLevel">100%</span></label>
            <input type="range" id="zoomSlider" min="10" max="500" value="100" style="width: 100px;">
            <button class="tool-action" id="fitToScreenBtn" title="ÈÄÇÂ∫îÂ±èÂπï">‚ä°</button>
        </div>

        <div class="tool-section" style="margin-left: auto;">
            <button class="tool-action" id="settingsBtn">‚öôÔ∏è ËÆæÁΩÆ</button>
            <button class="tool-action" id="helpBtn">‚ùì Â∏ÆÂä©</button>
        </div>
    </div>

    <!-- Â∑¶‰æßÂ∑•ÂÖ∑Èù¢Êùø -->
    <div class="left-panel">
        <div class="tool-btn active" data-tool="brush" title="ÁîªÁ¨îÂ∑•ÂÖ∑ (B)">
            <span class="icon">‚úèÔ∏è</span>
            <span class="label">ÁîªÁ¨î</span>
        </div>
        <div class="tool-btn" data-tool="eraser" title="Ê©°ÁöÆÊì¶ (E)">
            <span class="icon">üßπ</span>
            <span class="label">Ê©°ÁöÆ</span>
        </div>
        <div class="tool-btn" data-tool="eyedropper" title="Âê∏ÁÆ°Â∑•ÂÖ∑ (I)">
            <span class="icon">üíâ</span>
            <span class="label">Âê∏ÁÆ°</span>
        </div>
        <div class="tool-btn" data-tool="fill" title="Â°´ÂÖÖÂ∑•ÂÖ∑ (G)">
            <span class="icon">ü™£</span>
            <span class="label">Â°´ÂÖÖ</span>
        </div>
        <div class="tool-btn" data-tool="gradient" title="Ê∏êÂèòÂ∑•ÂÖ∑ (G)">
            <span class="icon">üåà</span>
            <span class="label">Ê∏êÂèò</span>
        </div>
        <div class="tool-btn" data-tool="shape" title="ÂΩ¢Áä∂Â∑•ÂÖ∑ (U)">
            <span class="icon">‚¨ú</span>
            <span class="label">ÂΩ¢Áä∂</span>
        </div>
        <div class="tool-btn" data-tool="text" title="ÊñáÂ≠óÂ∑•ÂÖ∑ (T)">
            <span class="icon">üìù</span>
            <span class="label">ÊñáÂ≠ó</span>
        </div>
        <div class="tool-btn" data-tool="select" title="ÈÄâÊã©Â∑•ÂÖ∑ (M)">
            <span class="icon">‚¨ö</span>
            <span class="label">ÈÄâÊã©</span>
        </div>
        <div class="tool-btn" data-tool="transform" title="ÂèòÊç¢Â∑•ÂÖ∑ (Ctrl+T)">
            <span class="icon">üîÑ</span>
            <span class="label">ÂèòÊç¢</span>
        </div>
        <div class="tool-btn" data-tool="symmetry" title="ÂØπÁß∞ÁªòÂà∂ (Y)">
            <span class="icon">üîÆ</span>
            <span class="label">ÂØπÁß∞</span>
        </div>
        <div class="tool-btn" data-tool="perspective" title="ÈÄèËßÜÊ†áÂ∞∫ (P)">
            <span class="icon">üìê</span>
            <span class="label">ÈÄèËßÜ</span>
        </div>
        <div class="tool-btn" data-tool="reference" title="ÂèÇËÄÉÂõæÁâá (R)">
            <span class="icon">üñºÔ∏è</span>
            <span class="label">ÂèÇËÄÉ</span>
        </div>
    </div>

    <!-- ÁîªÂ∏ÉÂÆπÂô® -->
    <div class="canvas-container" id="canvasContainer">
        <div class="canvas-viewport" id="canvasViewport">
            <canvas id="mainCanvas"></canvas>
            <canvas id="perspectiveOverlay" class="perspective-overlay" style="display: none;"></canvas>
            <div class="custom-cursor" id="customCursor" style="display: none;">
                <div class="cursor-ring" id="cursorRing"></div>
            </div>
        </div>
    </div>

    <!-- Âè≥‰æßÂ±ûÊÄßÈù¢Êùø -->
    <div class="right-panel">
        <!-- ÂõæÂ±ÇÈù¢Êùø -->
        <div class="panel-section">
            <div class="panel-title">
                <span>üìö</span>
                <span>ÂõæÂ±Ç</span>
                <button style="margin-left: auto;" id="addLayerBtn">‚ûï</button>
            </div>
            <div class="layers-panel" id="layersPanel">
                <!-- Âä®ÊÄÅÁîüÊàêÂõæÂ±ÇÂàóË°® -->
            </div>
            <div style="margin-top: 10px;">
                <label style="font-size: 11px;">Ê∑∑ÂêàÊ®°Âºè:</label>
                <select class="blend-mode-selector" id="blendModeSelect">
                    <option value="normal">Ê≠£Â∏∏</option>
                    <option value="multiply">Ê≠£ÁâáÂè†Â∫ï</option>
                    <option value="screen">Êª§Ëâ≤</option>
                    <option value="overlay">Âè†Âä†</option>
                    <option value="soft-light">ÊüîÂÖâ</option>
                    <option value="hard-light">Âº∫ÂÖâ</option>
                    <option value="color-dodge">È¢úËâ≤ÂáèÊ∑°</option>
                    <option value="color-burn">È¢úËâ≤Âä†Ê∑±</option>
                    <option value="darken">ÂèòÊöó</option>
                    <option value="lighten">Âèò‰∫Æ</option>
                    <option value="difference">Â∑ÆÂÄº</option>
                    <option value="exclusion">ÊéíÈô§</option>
                    <option value="hue">Ëâ≤Áõ∏</option>
                    <option value="saturation">È•±ÂíåÂ∫¶</option>
                    <option value="color">È¢úËâ≤</option>
                    <option value="luminosity">ÊòéÂ∫¶</option>
                </select>
                <div style="margin-top: 8px;">
                    <label style="font-size: 11px;">‰∏çÈÄèÊòéÂ∫¶: <span id="layerOpacityValue">100%</span></label>
                    <input type="range" class="slider" id="layerOpacitySlider" min="0" max="100" value="100">
                </div>
            </div>
        </div>

        <!-- Á¨îÂà∑ËÆæÁΩÆ -->
        <div class="panel-section" id="brushSettings">
            <div class="panel-title">
                <span>üñåÔ∏è</span>
                <span>Á¨îÂà∑ËÆæÁΩÆ</span>
            </div>

            <!-- Á¨îÂà∑È¢ÑËÆæ -->
            <div class="brush-presets" id="brushPresets">
                <!-- Âä®ÊÄÅÁîüÊàêÁ¨îÂà∑È¢ÑËÆæ -->
            </div>

            <!-- Á¨îÂà∑ÂèÇÊï∞ -->
            <div class="brush-controls" style="margin-top: 15px;">
                <div class="control-group">
                    <div class="control-label">
                        <span>Â§ßÂ∞è</span>
                        <span class="control-value" id="brushSizeValue">10px</span>
                    </div>
                    <input type="range" class="slider" id="brushSizeSlider" min="1" max="500" value="10">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Á°¨Â∫¶</span>
                        <span class="control-value" id="brushHardnessValue">100%</span>
                    </div>
                    <input type="range" class="slider" id="brushHardnessSlider" min="0" max="100" value="100">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>ÊµÅÈáè</span>
                        <span class="control-value" id="brushFlowValue">100%</span>
                    </div>
                    <input type="range" class="slider" id="brushFlowSlider" min="1" max="100" value="100">
                </div>

                <div class="control-group">
                    <div class="control-label">
                        <span>Èó¥Ë∑ù</span>
                        <span class="control-value" id="brushSpacingValue">25%</span>
                    </div>
                    <input type="range" class="slider" id="brushSpacingSlider" min="1" max="200" value="25">
                </div>
            </div>

            <!-- Âä®ÊÄÅËÆæÁΩÆ -->
            <div style="margin-top: 15px;">
                <label style="font-size: 11px; font-weight: 600;">ÂéãÂäõÊÑüÂ∫î:</label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 8px;">
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="pressureSize" checked> ÊéßÂà∂Â§ßÂ∞è
                    </label>
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="pressureOpacity" checked> ÊéßÂà∂‰∏çÈÄèÊòéÂ∫¶
                    </label>
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="pressureFlow"> ÊéßÂà∂ÊµÅÈáè
                    </label>
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="pressureHardness"> ÊéßÂà∂Á°¨Â∫¶
                    </label>
                </div>
            </div>

            <!-- ÂÄæÊñúÊÑüÂ∫î -->
            <div style="margin-top: 15px;">
                <label style="font-size: 11px; font-weight: 600;">ÂÄæÊñúÊÑüÂ∫î:</label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 8px;">
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="tiltAngle"> ÊéßÂà∂ËßíÂ∫¶
                    </label>
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="tiltShape"> ÊéßÂà∂ÂΩ¢Áä∂
                    </label>
                </div>
            </div>

            <!-- ÈÄüÂ∫¶ÊÑüÂ∫î -->
            <div style="margin-top: 15px;">
                <label style="font-size: 11px; font-weight: 600;">ÈÄüÂ∫¶ÊÑüÂ∫î:</label>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 8px;">
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="velocitySize"> ÊéßÂà∂Â§ßÂ∞è
                    </label>
                    <label style="font-size: 11px;">
                        <input type="checkbox" id="velocitySmooth"> Âπ≥ÊªëÂ§ÑÁêÜ
                    </label>
                </div>
            </div>

            <!-- Á∫πÁêÜËÆæÁΩÆ -->
            <div style="margin-top: 15px;">
                <label style="font-size: 11px; font-weight: 600;">Á∫πÁêÜ:</label>
                <select style="width: 100%; margin-top: 8px; padding: 6px; border: 1px solid #dee2e6; border-radius: 4px; font-size: 12px;" id="brushTexture">
                    <option value="none">Êó†</option>
                    <option value="canvas">ÁîªÂ∏ÉÁ∫πÁêÜ</option>
                    <option value="paper">Á∫∏Âº†Á∫πÁêÜ</option>
                    <option value="watercolor">Ê∞¥ÂΩ©Á∫∏</option>
                    <option value="rough">Á≤óÁ≥ôË°®Èù¢</option>
                    <option value="custom">Ëá™ÂÆö‰πâ...</option>
                </select>
            </div>
        </div>

        <!-- È¢úËâ≤Èù¢Êùø -->
        <div class="panel-section">
            <div class="panel-title">
                <span>üé®</span>
                <span>È¢úËâ≤</span>
            </div>

            <div class="color-picker-advanced">
                <!-- È¢úËâ≤Ê®°ÂºèÂàáÊç¢ -->
                <div class="color-mode-tabs">
                    <button class="color-mode-tab active" data-mode="rgb">RGB</button>
                    <button class="color-mode-tab" data-mode="hsl">HSL</button>
                    <button class="color-mode-tab" data-mode="lab">Lab</button>
                    <button class="color-mode-tab" data-mode="cmyk">CMYK</button>
                </div>

                <!-- È¢úËâ≤ËΩÆ -->
                <canvas id="colorWheel" class="color-wheel"></canvas>

                <!-- È¢úËâ≤ÂÄºËæìÂÖ• -->
                <div class="color-input-group" id="rgbInputs">
                    <div class="color-input">
                        <label>R</label>
                        <input type="number" id="colorR" min="0" max="255" value="255">
                    </div>
                    <div class="color-input">
                        <label>G</label>
                        <input type="number" id="colorG" min="0" max="255" value="107">
                    </div>
                    <div class="color-input">
                        <label>B</label>
                        <input type="number" id="colorB" min="0" max="255" value="107">
                    </div>
                </div>

                <!-- ÊúÄËøë‰ΩøÁî®ÁöÑÈ¢úËâ≤ -->
                <div style="margin-top: 15px;">
                    <label style="font-size: 11px; font-weight: 600;">ÊúÄËøë‰ΩøÁî®:</label>
                    <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; margin-top: 8px;" id="recentColors">
                        <!-- Âä®ÊÄÅÁîüÊàêÊúÄËøëÈ¢úËâ≤ -->
                    </div>
                </div>

                <!-- Ëâ≤Êùø -->
                <div style="margin-top: 15px;">
                    <label style="font-size: 11px; font-weight: 600;">Ëâ≤Êùø:</label>
                    <div style="display: grid; grid-template-columns: repeat(8, 1fr); gap: 4px; margin-top: 8px;" id="colorPalette">
                        <!-- Âä®ÊÄÅÁîüÊàêËâ≤Êùø -->
                    </div>
                </div>
            </div>
        </div>

        <!-- ÂØπÁß∞Ê®°Âºè -->
        <div class="panel-section" id="symmetrySettings" style="display: none;">
            <div class="panel-title">
                <span>üîÆ</span>
                <span>ÂØπÁß∞ÁªòÂà∂</span>
            </div>

            <div class="symmetry-controls">
                <div class="symmetry-mode" data-mode="none">
                    <div class="icon">‚≠ï</div>
                    <div class="name">Êó†</div>
                </div>
                <div class="symmetry-mode" data-mode="horizontal">
                    <div class="icon">‚ÜîÔ∏è</div>
                    <div class="name">Ê∞¥Âπ≥</div>
                </div>
                <div class="symmetry-mode" data-mode="vertical">
                    <div class="icon">‚ÜïÔ∏è</div>
                    <div class="name">ÂûÇÁõ¥</div>
                </div>
                <div class="symmetry-mode" data-mode="radial">
                    <div class="icon">‚ú≥Ô∏è</div>
                    <div class="name">ÂæÑÂêë</div>
                </div>
                <div class="symmetry-mode" data-mode="kaleidoscope">
                    <div class="icon">üå∫</div>
                    <div class="name">‰∏áËä±Á≠í</div>
                </div>
                <div class="symmetry-mode" data-mode="custom">
                    <div class="icon">‚öôÔ∏è</div>
                    <div class="name">Ëá™ÂÆö‰πâ</div>
                </div>
            </div>

            <div style="margin-top: 15px;">
                <label style="font-size: 11px;">ÂàÜÊÆµÊï∞: <span id="symmetrySegments">4</span></label>
                <input type="range" class="slider" id="symmetrySegmentsSlider" min="2" max="32" value="4">
            </div>
        </div>

        <!-- ÈÄèËßÜËÆæÁΩÆ -->
        <div class="panel-section" id="perspectiveSettings" style="display: none;">
            <div class="panel-title">
                <span>üìê</span>
                <span>ÈÄèËßÜÊ†áÂ∞∫</span>
            </div>

            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px;">
                <button class="perspective-mode" data-points="1">1ÁÇπÈÄèËßÜ</button>
                <button class="perspective-mode" data-points="2">2ÁÇπÈÄèËßÜ</button>
                <button class="perspective-mode" data-points="3">3ÁÇπÈÄèËßÜ</button>
                <button class="perspective-mode" data-points="custom">Ëá™ÂÆö‰πâ</button>
            </div>

            <div style="margin-top: 15px;">
                <label style="font-size: 11px;">
                    <input type="checkbox" id="perspectiveSnap" checked> Âê∏ÈôÑÂà∞ÈÄèËßÜÁ∫ø
                </label>
            </div>

            <div style="margin-top: 8px;">
                <label style="font-size: 11px;">ÁΩëÊ†ºÂØÜÂ∫¶: <span id="gridDensity">10</span></label>
                <input type="range" class="slider" id="gridDensitySlider" min="5" max="50" value="10">
            </div>
        </div>

        <!-- ÂéÜÂè≤ËÆ∞ÂΩï -->
        <div class="panel-section">
            <div class="panel-title">
                <span>‚è∞</span>
                <span>ÂéÜÂè≤ËÆ∞ÂΩï</span>
            </div>
            <div class="history-timeline" id="historyTimeline">
                <!-- Âä®ÊÄÅÁîüÊàêÂéÜÂè≤ËÆ∞ÂΩï -->
            </div>
        </div>
    </div>

    <!-- ÂèÇËÄÉÂõæÁâáÁ™óÂè£ -->
    <div class="reference-window" id="referenceWindow">
        <div class="reference-header">
            <span>ÂèÇËÄÉÂõæÁâá</span>
            <button id="closeReference">‚úñÔ∏è</button>
        </div>
        <div class="reference-content">
            <img id="referenceImage" src="" alt="ÂèÇËÄÉÂõæÁâá">
        </div>
    </div>

    <!-- Âø´Êç∑ÈîÆÊèêÁ§∫ -->
    <div class="shortcut-hint" id="shortcutHint"></div>

    <!-- Âä†ËΩΩÂä®Áîª -->
    <div class="loader" id="loader">
        <div class="loader-spinner"></div>
    </div>

    <!-- ÊÄßËÉΩÁõëËßÜÂô® -->
    <div class="performance-monitor" id="performanceMonitor">
        FPS: <span id="fps">60</span><br>
        Memory: <span id="memory">0</span> MB<br>
        Layers: <span id="layerCount">1</span>
    </div>

    <!-- ‰∫ëÁ´ØÂêåÊ≠•Áä∂ÊÄÅ -->
    <div class="sync-status" id="syncStatus">
        <div class="sync-icon">üîÑ</div>
        <span id="syncMessage">ÂêåÊ≠•‰∏≠...</span>
    </div>

    <!-- Â∑•ÂÖ∑ÊèêÁ§∫ -->
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Â∫îÁî®Á®ãÂ∫è‰∏ªÊ®°Âùó
        class DrawingApp {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d', {
                    willReadFrequently: true,
                    alpha: true
                });

                // ËÆæÁΩÆÁîªÂ∏ÉÂ§ßÂ∞è
                this.setupCanvas();

                // ÂàùÂßãÂåñÂêÑ‰∏™Ê®°Âùó
                this.brushEngine = new BrushEngine(this);
                this.layerManager = new LayerManager(this);
                this.colorSystem = new ColorSystem(this);
                this.historyManager = new HistoryManager(this);
                this.symmetryTool = new SymmetryTool(this);
                this.perspectiveTool = new PerspectiveTool(this);
                this.transformTool = new TransformTool(this);

                // Â∑•ÂÖ∑Áä∂ÊÄÅ
                this.currentTool = 'brush';
                this.isDrawing = false;
                this.lastPoint = null;

                // ÁîªÂ∏ÉÂèòÊç¢
                this.zoom = 1;
                this.panX = 0;
                this.panY = 0;

                // ÂàùÂßãÂåñ‰∫ã‰ª∂ÁõëÂê¨
                this.initEventListeners();

                // ÂàùÂßãÂåñUI
                this.initUI();

                // ÊÄßËÉΩÁõëÊéß
                this.performanceMonitor = new PerformanceMonitor();

                // ‰∫ëÁ´ØÂêåÊ≠•ÔºàÊ®°ÊãüÔºâ
                this.cloudSync = new CloudSync();
            }

            setupCanvas() {
                const container = document.getElementById('canvasContainer');
                const rect = container.getBoundingClientRect();

                this.canvas.width = 1920;  // ÈªòËÆ§ÁîªÂ∏ÉÂ§ßÂ∞è
                this.canvas.height = 1080;

                // ËÆæÁΩÆÁîªÂ∏ÉÊ†∑Âºè
                this.canvas.style.width = '100%';
                this.canvas.style.height = '100%';
                this.canvas.style.imageRendering = 'crisp-edges';
            }

            initEventListeners() {
                // Èº†Ê†á‰∫ã‰ª∂
                this.canvas.addEventListener('mousedown', this.handleMouseDown.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMouseMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleMouseUp.bind(this));
                this.canvas.addEventListener('mouseleave', this.handleMouseUp.bind(this));

                // Ëß¶Êë∏‰∫ã‰ª∂ÔºàÊîØÊåÅÂéãÊÑüÔºâ
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });

                // ÊåáÈíà‰∫ã‰ª∂ÔºàÊîØÊåÅÊõ¥È´òÁ∫ßÁöÑÂéãÊÑüÂíåÂÄæÊñúÔºâ
                if (window.PointerEvent) {
                    this.canvas.addEventListener('pointerdown', this.handlePointerDown.bind(this));
                    this.canvas.addEventListener('pointermove', this.handlePointerMove.bind(this));
                    this.canvas.addEventListener('pointerup', this.handlePointerUp.bind(this));
                }

                // ÈîÆÁõòÂø´Êç∑ÈîÆ
                document.addEventListener('keydown', this.handleKeyDown.bind(this));
                document.addEventListener('keyup', this.handleKeyUp.bind(this));

                // ÊªöËΩÆÁº©Êîæ
                this.canvas.addEventListener('wheel', this.handleWheel.bind(this), { passive: false });

                // Á™óÂè£Ë∞ÉÊï¥
                window.addEventListener('resize', this.handleResize.bind(this));
            }

            initUI() {
                // Â∑•ÂÖ∑ÊåâÈíÆ
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.addEventListener('click', () => {
                        this.selectTool(btn.dataset.tool);
                    });
                });

                // Á¨îÂà∑ËÆæÁΩÆ
                this.initBrushControls();

                // ÂõæÂ±ÇÁÆ°ÁêÜ
                this.layerManager.initUI();

                // È¢úËâ≤Á≥ªÁªü
                this.colorSystem.initUI();

                // ÂéÜÂè≤ËÆ∞ÂΩï
                this.historyManager.initUI();

                // Áº©ÊîæÊéßÂà∂
                this.initZoomControls();

                // Êñá‰ª∂Êìç‰Ωú
                this.initFileControls();
            }

            initBrushControls() {
                // Á¨îÂà∑Â§ßÂ∞è
                const sizeSlider = document.getElementById('brushSizeSlider');
                sizeSlider.addEventListener('input', (e) => {
                    this.brushEngine.setSize(e.target.value);
                    document.getElementById('brushSizeValue').textContent = e.target.value + 'px';
                });

                // Á°¨Â∫¶
                const hardnessSlider = document.getElementById('brushHardnessSlider');
                hardnessSlider.addEventListener('input', (e) => {
                    this.brushEngine.setHardness(e.target.value / 100);
                    document.getElementById('brushHardnessValue').textContent = e.target.value + '%';
                });

                // ÊµÅÈáè
                const flowSlider = document.getElementById('brushFlowSlider');
                flowSlider.addEventListener('input', (e) => {
                    this.brushEngine.setFlow(e.target.value / 100);
                    document.getElementById('brushFlowValue').textContent = e.target.value + '%';
                });

                // Èó¥Ë∑ù
                const spacingSlider = document.getElementById('brushSpacingSlider');
                spacingSlider.addEventListener('input', (e) => {
                    this.brushEngine.setSpacing(e.target.value / 100);
                    document.getElementById('brushSpacingValue').textContent = e.target.value + '%';
                });

                // ÂéãÂäõÊÑüÂ∫î
                document.getElementById('pressureSize').addEventListener('change', (e) => {
                    this.brushEngine.pressureSettings.size = e.target.checked;
                });

                document.getElementById('pressureOpacity').addEventListener('change', (e) => {
                    this.brushEngine.pressureSettings.opacity = e.target.checked;
                });

                document.getElementById('pressureFlow').addEventListener('change', (e) => {
                    this.brushEngine.pressureSettings.flow = e.target.checked;
                });

                document.getElementById('pressureHardness').addEventListener('change', (e) => {
                    this.brushEngine.pressureSettings.hardness = e.target.checked;
                });

                // ÂÄæÊñúÊÑüÂ∫î
                document.getElementById('tiltAngle').addEventListener('change', (e) => {
                    this.brushEngine.tiltSettings.angle = e.target.checked;
                });

                document.getElementById('tiltShape').addEventListener('change', (e) => {
                    this.brushEngine.tiltSettings.shape = e.target.checked;
                });

                // ÈÄüÂ∫¶ÊÑüÂ∫î
                document.getElementById('velocitySize').addEventListener('change', (e) => {
                    this.brushEngine.velocitySettings.size = e.target.checked;
                });

                document.getElementById('velocitySmooth').addEventListener('change', (e) => {
                    this.brushEngine.velocitySettings.smooth = e.target.checked;
                });

                // Á∫πÁêÜ
                document.getElementById('brushTexture').addEventListener('change', (e) => {
                    this.brushEngine.setTexture(e.target.value);
                });

                // ÁîüÊàêÁ¨îÂà∑È¢ÑËÆæ
                this.generateBrushPresets();
            }

            generateBrushPresets() {
                const presetsContainer = document.getElementById('brushPresets');
                const presets = [
                    { name: 'ÈìÖÁ¨î', type: 'pencil', size: 2, hardness: 0.8 },
                    { name: 'Èí¢Á¨î', type: 'pen', size: 5, hardness: 1 },
                    { name: 'È©¨ÂÖãÁ¨î', type: 'marker', size: 15, hardness: 0.5 },
                    { name: 'Ê∞¥ÂΩ©', type: 'watercolor', size: 20, hardness: 0.2 },
                    { name: 'Ê≤πÁîª', type: 'oil', size: 30, hardness: 0.7 },
                    { name: 'Á≤âÁ¨î', type: 'chalk', size: 25, hardness: 0.3 },
                    { name: 'Âñ∑Êû™', type: 'airbrush', size: 40, hardness: 0.1 },
                    { name: 'Á∫πÁêÜÁ¨î', type: 'textured', size: 35, hardness: 0.6 }
                ];

                presets.forEach(preset => {
                    const div = document.createElement('div');
                    div.className = 'brush-preset';
                    div.title = preset.name;
                    div.dataset.preset = JSON.stringify(preset);

                    const canvas = document.createElement('canvas');
                    canvas.width = 50;
                    canvas.height = 50;
                    this.drawBrushPreview(canvas, preset);

                    div.appendChild(canvas);
                    div.addEventListener('click', () => {
                        this.brushEngine.loadPreset(preset);
                        document.querySelectorAll('.brush-preset').forEach(p => p.classList.remove('active'));
                        div.classList.add('active');
                    });

                    presetsContainer.appendChild(div);
                });
            }

            drawBrushPreview(canvas, preset) {
                const ctx = canvas.getContext('2d');
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // ÁªòÂà∂È¢ÑËßàÁ¨îËß¶
                ctx.strokeStyle = '#667eea';
                ctx.lineWidth = preset.size / 2;
                ctx.lineCap = 'round';
                ctx.globalAlpha = preset.hardness;

                ctx.beginPath();
                ctx.moveTo(10, 40);
                ctx.quadraticCurveTo(25, 10, 40, 40);
                ctx.stroke();
            }

            initZoomControls() {
                const zoomSlider = document.getElementById('zoomSlider');
                zoomSlider.addEventListener('input', (e) => {
                    this.setZoom(e.target.value / 100);
                });

                document.getElementById('fitToScreenBtn').addEventListener('click', () => {
                    this.fitToScreen();
                });
            }

            initFileControls() {
                document.getElementById('newFileBtn').addEventListener('click', () => {
                    if (confirm('ÂàõÂª∫Êñ∞Êñá‰ª∂Â∞ÜÊ∏ÖÁ©∫ÂΩìÂâçÁîªÂ∏ÉÔºåÊòØÂê¶ÁªßÁª≠Ôºü')) {
                        this.newFile();
                    }
                });

                document.getElementById('openFileBtn').addEventListener('click', () => {
                    this.openFile();
                });

                document.getElementById('saveFileBtn').addEventListener('click', () => {
                    this.saveFile();
                });

                document.getElementById('exportBtn').addEventListener('click', () => {
                    this.exportImage();
                });
            }

            selectTool(tool) {
                this.currentTool = tool;

                // Êõ¥Êñ∞UI
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tool === tool);
                });

                // ÊòæÁ§∫/ÈöêËóèÁõ∏ÂÖ≥ËÆæÁΩÆÈù¢Êùø
                document.getElementById('brushSettings').style.display =
                    (tool === 'brush' || tool === 'eraser') ? 'block' : 'none';
                document.getElementById('symmetrySettings').style.display =
                    tool === 'symmetry' ? 'block' : 'none';
                document.getElementById('perspectiveSettings').style.display =
                    tool === 'perspective' ? 'block' : 'none';

                // Êõ¥Êñ∞ÂÖâÊ†á
                this.updateCursor();
            }

            updateCursor() {
                const cursor = document.getElementById('customCursor');
                const ring = document.getElementById('cursorRing');

                if (this.currentTool === 'brush' || this.currentTool === 'eraser') {
                    cursor.style.display = 'block';
                    ring.style.width = this.brushEngine.size + 'px';
                    ring.style.height = this.brushEngine.size + 'px';
                } else {
                    cursor.style.display = 'none';
                }
            }

            handleMouseDown(e) {
                this.startDrawing(e);
            }

            handleMouseMove(e) {
                this.continueDrawing(e);
                this.updateCustomCursor(e);
            }

            handleMouseUp(e) {
                this.stopDrawing(e);
            }

            handleTouchStart(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    this.startDrawing(e.touches[0]);
                }
            }

            handleTouchMove(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    this.continueDrawing(e.touches[0]);
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                this.stopDrawing(e.changedTouches[0]);
            }

            handlePointerDown(e) {
                this.pointerPressure = e.pressure || 1;
                this.pointerTiltX = e.tiltX || 0;
                this.pointerTiltY = e.tiltY || 0;
                this.startDrawing(e);
            }

            handlePointerMove(e) {
                this.pointerPressure = e.pressure || 1;
                this.pointerTiltX = e.tiltX || 0;
                this.pointerTiltY = e.tiltY || 0;
                this.continueDrawing(e);
                this.updateCustomCursor(e);
            }

            handlePointerUp(e) {
                this.stopDrawing(e);
            }

            handleKeyDown(e) {
                // Âø´Êç∑ÈîÆÂ§ÑÁêÜ
                const shortcuts = {
                    'b': () => this.selectTool('brush'),
                    'e': () => this.selectTool('eraser'),
                    'i': () => this.selectTool('eyedropper'),
                    'g': () => this.selectTool('fill'),
                    't': () => this.selectTool('text'),
                    'm': () => this.selectTool('select'),
                    'y': () => this.selectTool('symmetry'),
                    'p': () => this.selectTool('perspective'),
                    'r': () => this.selectTool('reference'),
                    'z': () => e.ctrlKey && this.historyManager.undo(),
                    'y': () => e.ctrlKey && this.historyManager.redo(),
                    's': () => e.ctrlKey && this.saveFile(),
                    'o': () => e.ctrlKey && this.openFile(),
                    'n': () => e.ctrlKey && this.newFile(),
                    '[': () => this.brushEngine.decreaseSize(),
                    ']': () => this.brushEngine.increaseSize(),
                };

                const key = e.key.toLowerCase();
                if (shortcuts[key]) {
                    e.preventDefault();
                    shortcuts[key]();

                    // ÊòæÁ§∫Âø´Êç∑ÈîÆÊèêÁ§∫
                    this.showShortcutHint(key);
                }

                // ShiftÈîÆÊåâ‰ΩèÊó∂ÂàáÊç¢Âà∞Âê∏ÁÆ°Â∑•ÂÖ∑
                if (e.key === 'Alt' && !this.altPressed) {
                    this.altPressed = true;
                    this.previousTool = this.currentTool;
                    this.selectTool('eyedropper');
                }
            }

            handleKeyUp(e) {
                if (e.key === 'Alt' && this.altPressed) {
                    this.altPressed = false;
                    this.selectTool(this.previousTool);
                }
            }

            handleWheel(e) {
                e.preventDefault();

                if (e.ctrlKey) {
                    // Áº©Êîæ
                    const delta = e.deltaY > 0 ? 0.9 : 1.1;
                    this.setZoom(this.zoom * delta);
                } else {
                    // Âπ≥Áßª
                    this.panX += e.deltaX;
                    this.panY += e.deltaY;
                    this.updateViewport();
                }
            }

            handleResize() {
                this.updateViewport();
            }

            startDrawing(e) {
                const point = this.getCanvasPoint(e);
                this.isDrawing = true;
                this.lastPoint = point;

                // ËÆ∞ÂΩïËµ∑ÂßãÊó∂Èó¥ÔºàÁî®‰∫éÈÄüÂ∫¶ËÆ°ÁÆóÔºâ
                this.lastTime = performance.now();
                this.velocity = 0;

                // ‰øùÂ≠òÂéÜÂè≤Áä∂ÊÄÅ
                this.historyManager.saveState();

                // Ê†πÊçÆÂ∑•ÂÖ∑ÊâßË°åÁõ∏Â∫îÊìç‰Ωú
                switch (this.currentTool) {
                    case 'brush':
                    case 'eraser':
                        this.brushEngine.startStroke(point, this.getInputData(e));
                        break;
                    case 'eyedropper':
                        this.colorSystem.pickColor(point);
                        break;
                    case 'fill':
                        this.fillArea(point);
                        break;
                    // ... ÂÖ∂‰ªñÂ∑•ÂÖ∑
                }
            }

            continueDrawing(e) {
                const point = this.getCanvasPoint(e);

                // ËÆ°ÁÆóÈÄüÂ∫¶
                const now = performance.now();
                const dt = now - this.lastTime;
                const distance = this.lastPoint ?
                    Math.sqrt(Math.pow(point.x - this.lastPoint.x, 2) +
                             Math.pow(point.y - this.lastPoint.y, 2)) : 0;
                this.velocity = distance / dt;
                this.lastTime = now;

                if (this.isDrawing) {
                    switch (this.currentTool) {
                        case 'brush':
                        case 'eraser':
                            if (this.lastPoint) {
                                this.brushEngine.continueStroke(
                                    this.lastPoint,
                                    point,
                                    this.getInputData(e)
                                );
                            }
                            break;
                        // ... ÂÖ∂‰ªñÂ∑•ÂÖ∑
                    }
                }

                this.lastPoint = point;
            }

            stopDrawing(e) {
                if (this.isDrawing) {
                    this.isDrawing = false;

                    switch (this.currentTool) {
                        case 'brush':
                        case 'eraser':
                            this.brushEngine.endStroke();
                            break;
                        // ... ÂÖ∂‰ªñÂ∑•ÂÖ∑
                    }

                    // Êõ¥Êñ∞ÂõæÂ±ÇÁº©Áï•Âõæ
                    this.layerManager.updateThumbnails();
                }
            }

            getCanvasPoint(e) {
                const rect = this.canvas.getBoundingClientRect();
                const x = (e.clientX - rect.left) / this.zoom - this.panX;
                const y = (e.clientY - rect.top) / this.zoom - this.panY;
                return { x, y };
            }

            getInputData(e) {
                return {
                    pressure: this.pointerPressure || (e.pressure || 1),
                    tiltX: this.pointerTiltX || (e.tiltX || 0),
                    tiltY: this.pointerTiltY || (e.tiltY || 0),
                    velocity: this.velocity || 0,
                    time: performance.now()
                };
            }

            updateCustomCursor(e) {
                const cursor = document.getElementById('customCursor');
                if (cursor.style.display !== 'none') {
                    cursor.style.left = e.clientX + 'px';
                    cursor.style.top = e.clientY + 'px';
                }
            }

            setZoom(zoom) {
                this.zoom = Math.max(0.1, Math.min(5, zoom));
                document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
                document.getElementById('zoomSlider').value = Math.round(this.zoom * 100);
                this.updateViewport();
            }

            fitToScreen() {
                const container = document.getElementById('canvasContainer');
                const containerRect = container.getBoundingClientRect();

                const scaleX = containerRect.width / this.canvas.width;
                const scaleY = containerRect.height / this.canvas.height;
                const scale = Math.min(scaleX, scaleY) * 0.9;

                this.setZoom(scale);
                this.panX = 0;
                this.panY = 0;
                this.updateViewport();
            }

            updateViewport() {
                const viewport = document.getElementById('canvasViewport');
                viewport.style.transform = `scale(${this.zoom}) translate(${this.panX}px, ${this.panY}px)`;
            }

            showShortcutHint(key) {
                const hint = document.getElementById('shortcutHint');
                const shortcuts = {
                    'b': 'ÁîªÁ¨îÂ∑•ÂÖ∑',
                    'e': 'Ê©°ÁöÆÊì¶',
                    'i': 'Âê∏ÁÆ°Â∑•ÂÖ∑',
                    // ... ÂÖ∂‰ªñÂø´Êç∑ÈîÆ
                };

                hint.textContent = shortcuts[key] || key.toUpperCase();
                hint.classList.add('show');

                setTimeout(() => {
                    hint.classList.remove('show');
                }, 1500);
            }

            fillArea(point) {
                // ÂÆûÁé∞Êô∫ËÉΩÂ°´ÂÖÖÁÆóÊ≥ï
                const imageData = this.ctx.getImageData(0, 0, this.canvas.width, this.canvas.height);
                const targetColor = this.getPixelColor(imageData, Math.floor(point.x), Math.floor(point.y));
                const fillColor = this.colorSystem.getCurrentColor();

                // ‰ΩøÁî®ÊîπËøõÁöÑÂ°´ÂÖÖÁÆóÊ≥ïÔºàÊîØÊåÅÂÆπÂ∑ÆÔºâ
                this.floodFill(imageData, point.x, point.y, targetColor, fillColor, 10);

                this.ctx.putImageData(imageData, 0, 0);
            }

            floodFill(imageData, x, y, targetColor, fillColor, tolerance) {
                // ÂÆûÁé∞Â∏¶ÂÆπÂ∑ÆÁöÑÊ¥™Ê∞¥Â°´ÂÖÖÁÆóÊ≥ï
                // ... ÁÆóÊ≥ïÂÆûÁé∞
            }

            getPixelColor(imageData, x, y) {
                const index = (y * imageData.width + x) * 4;
                return {
                    r: imageData.data[index],
                    g: imageData.data[index + 1],
                    b: imageData.data[index + 2],
                    a: imageData.data[index + 3]
                };
            }

            newFile() {
                this.layerManager.clear();
                this.historyManager.clear();
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            openFile() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = 'image/*,.psd';
                input.onchange = (e) => {
                    const file = e.target.files[0];
                    if (file) {
                        this.loadFile(file);
                    }
                };
                input.click();
            }

            loadFile(file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    if (file.name.endsWith('.psd')) {
                        // Â§ÑÁêÜPSDÊñá‰ª∂
                        this.loadPSDFile(e.target.result);
                    } else {
                        // Â§ÑÁêÜÊôÆÈÄöÂõæÁâá
                        const img = new Image();
                        img.onload = () => {
                            this.canvas.width = img.width;
                            this.canvas.height = img.height;
                            this.ctx.drawImage(img, 0, 0);
                            this.historyManager.saveState();
                        };
                        img.src = e.target.result;
                    }
                };
                reader.readAsDataURL(file);
            }

            loadPSDFile(data) {
                // ÂÆûÁé∞PSDÊñá‰ª∂Ëß£Êûê
                console.log('PSDÊñá‰ª∂ÊîØÊåÅÊ≠£Âú®ÂºÄÂèë‰∏≠...');
            }

            saveFile() {
                // ‰øùÂ≠ò‰∏∫‰∏ìÊúâÊ†ºÂºèÔºàÂåÖÂê´ÂõæÂ±Ç‰ø°ÊÅØÔºâ
                const projectData = {
                    version: '1.0',
                    canvas: {
                        width: this.canvas.width,
                        height: this.canvas.height
                    },
                    layers: this.layerManager.exportLayers(),
                    history: this.historyManager.exportHistory()
                };

                const blob = new Blob([JSON.stringify(projectData)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `drawing_${Date.now()}.xhp`;
                a.click();
                URL.revokeObjectURL(url);
            }

            exportImage() {
                const canvas = document.createElement('canvas');
                canvas.width = this.canvas.width;
                canvas.height = this.canvas.height;
                const ctx = canvas.getContext('2d');

                // ÂêàÂπ∂ÊâÄÊúâÂõæÂ±Ç
                this.layerManager.renderAllLayers(ctx);

                // ÂØºÂá∫‰∏∫PNG
                canvas.toBlob((blob) => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `export_${Date.now()}.png`;
                    a.click();
                    URL.revokeObjectURL(url);
                }, 'image/png');
            }
        }

        // Á¨îÂà∑ÂºïÊìé
        class BrushEngine {
            constructor(app) {
                this.app = app;
                this.ctx = app.ctx;

                // Âü∫Á°ÄÂèÇÊï∞
                this.size = 10;
                this.hardness = 1;
                this.flow = 1;
                this.spacing = 0.25;
                this.smoothing = 0.5;

                // ÂéãÂäõÊÑüÂ∫îËÆæÁΩÆ
                this.pressureSettings = {
                    size: true,
                    opacity: true,
                    flow: false,
                    hardness: false
                };

                // ÂÄæÊñúÊÑüÂ∫îËÆæÁΩÆ
                this.tiltSettings = {
                    angle: false,
                    shape: false
                };

                // ÈÄüÂ∫¶ÊÑüÂ∫îËÆæÁΩÆ
                this.velocitySettings = {
                    size: false,
                    smooth: false
                };

                // Á∫πÁêÜ
                this.texture = null;
                this.textureStrength = 0.5;

                // Á¨îËß¶ÁºìÂÜ≤
                this.strokeBuffer = [];
                this.lastStamp = null;

                // Ëá™ÁÑ∂Â™í‰ªãÊ®°Êãü
                this.wetness = 0;
                this.bleedAmount = 0;
                this.paperTexture = null;

                // ÂàùÂßãÂåñÁ∫πÁêÜ
                this.initTextures();
            }

            initTextures() {
                // ÂàõÂª∫Á®ãÂ∫èÂåñÁ∫πÁêÜ
                this.textures = {
                    canvas: this.createCanvasTexture(),
                    paper: this.createPaperTexture(),
                    watercolor: this.createWatercolorTexture(),
                    rough: this.createRoughTexture()
                };
            }

            createCanvasTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // ÁîüÊàêÁîªÂ∏ÉÁ∫πÁêÜÂõæÊ°à
                for (let i = 0; i < 256; i += 4) {
                    for (let j = 0; j < 256; j += 4) {
                        ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.1})`;
                        ctx.fillRect(i, j, 2, 2);
                    }
                }

                return canvas;
            }

            createPaperTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // ÁîüÊàêÁ∫∏Âº†Á∫πÁêÜ
                const imageData = ctx.createImageData(256, 256);
                for (let i = 0; i < imageData.data.length; i += 4) {
                    const noise = Math.random() * 20;
                    imageData.data[i] = 255 - noise;
                    imageData.data[i + 1] = 255 - noise;
                    imageData.data[i + 2] = 255 - noise;
                    imageData.data[i + 3] = 255;
                }
                ctx.putImageData(imageData, 0, 0);

                return canvas;
            }

            createWatercolorTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // ÁîüÊàêÊ∞¥ÂΩ©Á∫πÁêÜ
                for (let i = 0; i < 50; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.05})`;
                    ctx.beginPath();
                    ctx.arc(
                        Math.random() * 256,
                        Math.random() * 256,
                        Math.random() * 30 + 10,
                        0, Math.PI * 2
                    );
                    ctx.fill();
                }

                return canvas;
            }

            createRoughTexture() {
                const canvas = document.createElement('canvas');
                canvas.width = 256;
                canvas.height = 256;
                const ctx = canvas.getContext('2d');

                // ÁîüÊàêÁ≤óÁ≥ôË°®Èù¢Á∫πÁêÜ
                for (let i = 0; i < 1000; i++) {
                    ctx.fillStyle = `rgba(0,0,0,${Math.random() * 0.2})`;
                    ctx.fillRect(
                        Math.random() * 256,
                        Math.random() * 256,
                        Math.random() * 3,
                        Math.random() * 3
                    );
                }

                return canvas;
            }

            setTexture(textureName) {
                if (textureName === 'none') {
                    this.texture = null;
                } else if (this.textures[textureName]) {
                    this.texture = this.textures[textureName];
                }
            }

            startStroke(point, inputData) {
                this.strokeBuffer = [point];
                this.lastStamp = null;

                // ËÆæÁΩÆÁîªÁ¨îÊ†∑Âºè
                this.setupBrush(inputData);

                // ÁªòÂà∂Ëµ∑ÂßãÁÇπ
                this.drawStamp(point, inputData);
            }

            continueStroke(from, to, inputData) {
                // Âπ≥ÊªëÂ§ÑÁêÜ
                if (this.velocitySettings.smooth) {
                    to = this.smoothPoint(from, to);
                }

                // ËÆ°ÁÆóÈúÄË¶ÅÁöÑÂç∞Á´†Êï∞Èáè
                const distance = Math.sqrt(
                    Math.pow(to.x - from.x, 2) +
                    Math.pow(to.y - from.y, 2)
                );

                const steps = Math.max(1, Math.floor(distance / (this.size * this.spacing)));

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const point = {
                        x: from.x + (to.x - from.x) * t,
                        y: from.y + (to.y - from.y) * t
                    };

                    // Ê†πÊçÆÈÄüÂ∫¶Ë∞ÉÊï¥ËæìÂÖ•Êï∞ÊçÆ
                    const adjustedData = this.adjustInputData(inputData);

                    this.drawStamp(point, adjustedData);
                }

                this.strokeBuffer.push(to);
                if (this.strokeBuffer.length > 10) {
                    this.strokeBuffer.shift();
                }
            }

            endStroke() {
                // Â∫îÁî®ÊúÄÁªàÁöÑÊ∑∑ÂêàÊïàÊûú
                if (this.wetness > 0) {
                    this.applyWetEdges();
                }

                this.strokeBuffer = [];
                this.lastStamp = null;
            }

            setupBrush(inputData) {
                const ctx = this.ctx;

                // ËÆæÁΩÆÂü∫Á°ÄÂ±ûÊÄß
                ctx.globalCompositeOperation = this.app.currentTool === 'eraser' ?
                    'destination-out' : 'source-over';

                // ËÆ°ÁÆóÂÆûÈôÖÂÄº
                let actualSize = this.size;
                let actualOpacity = this.flow;
                let actualHardness = this.hardness;

                // Â∫îÁî®ÂéãÂäõÊÑüÂ∫î
                if (this.pressureSettings.size) {
                    actualSize *= (0.3 + inputData.pressure * 0.7);
                }
                if (this.pressureSettings.opacity) {
                    actualOpacity *= inputData.pressure;
                }
                if (this.pressureSettings.hardness) {
                    actualHardness *= inputData.pressure;
                }

                // Â∫îÁî®ÈÄüÂ∫¶ÊÑüÂ∫î
                if (this.velocitySettings.size) {
                    const velocityFactor = Math.min(1, inputData.velocity / 100);
                    actualSize *= (1 - velocityFactor * 0.5);
                }

                // Â∫îÁî®ÂÄæÊñúÊÑüÂ∫î
                if (this.tiltSettings.angle) {
                    const tiltAngle = Math.atan2(inputData.tiltY, inputData.tiltX);
                    ctx.rotate(tiltAngle);
                }

                ctx.globalAlpha = actualOpacity;

                return { actualSize, actualOpacity, actualHardness };
            }

            drawStamp(point, inputData) {
                const ctx = this.ctx;
                const { actualSize, actualOpacity, actualHardness } = this.setupBrush(inputData);

                ctx.save();

                // ÂàõÂª∫Á¨îÂà∑ÂõæÁ´†
                const stampCanvas = document.createElement('canvas');
                stampCanvas.width = actualSize * 2;
                stampCanvas.height = actualSize * 2;
                const stampCtx = stampCanvas.getContext('2d');

                // ÁªòÂà∂Á¨îÂà∑ÂΩ¢Áä∂
                if (actualHardness < 1) {
                    // ÊüîËæπÁ¨îÂà∑
                    const gradient = stampCtx.createRadialGradient(
                        actualSize, actualSize, 0,
                        actualSize, actualSize, actualSize
                    );

                    gradient.addColorStop(0, `rgba(${this.app.colorSystem.currentColor.r},${this.app.colorSystem.currentColor.g},${this.app.colorSystem.currentColor.b},1)`);
                    gradient.addColorStop(actualHardness, `rgba(${this.app.colorSystem.currentColor.r},${this.app.colorSystem.currentColor.g},${this.app.colorSystem.currentColor.b},1)`);
                    gradient.addColorStop(1, `rgba(${this.app.colorSystem.currentColor.r},${this.app.colorSystem.currentColor.g},${this.app.colorSystem.currentColor.b},0)`);

                    stampCtx.fillStyle = gradient;
                    stampCtx.fillRect(0, 0, stampCanvas.width, stampCanvas.height);
                } else {
                    // Á°¨ËæπÁ¨îÂà∑
                    stampCtx.fillStyle = `rgb(${this.app.colorSystem.currentColor.r},${this.app.colorSystem.currentColor.g},${this.app.colorSystem.currentColor.b})`;
                    stampCtx.beginPath();
                    stampCtx.arc(actualSize, actualSize, actualSize, 0, Math.PI * 2);
                    stampCtx.fill();
                }

                // Â∫îÁî®Á∫πÁêÜ
                if (this.texture) {
                    stampCtx.globalCompositeOperation = 'multiply';
                    stampCtx.globalAlpha = this.textureStrength;
                    stampCtx.drawImage(this.texture, 0, 0, stampCanvas.width, stampCanvas.height);
                }

                // ÁªòÂà∂Âà∞‰∏ªÁîªÂ∏É
                ctx.drawImage(
                    stampCanvas,
                    point.x - actualSize,
                    point.y - actualSize
                );

                ctx.restore();

                this.lastStamp = { point, size: actualSize };
            }

            smoothPoint(from, to) {
                if (this.strokeBuffer.length < 2) {
                    return to;
                }

                // ‰ΩøÁî®Ë¥ùÂ°ûÂ∞îÊõ≤Á∫øÂπ≥Êªë
                const smoothing = this.smoothing;
                return {
                    x: from.x + (to.x - from.x) * (1 - smoothing),
                    y: from.y + (to.y - from.y) * (1 - smoothing)
                };
            }

            adjustInputData(inputData) {
                // Ê†πÊçÆÂêÑÁßçËÆæÁΩÆË∞ÉÊï¥ËæìÂÖ•Êï∞ÊçÆ
                const adjusted = { ...inputData };

                // ÈÄüÂ∫¶Âπ≥Êªë
                if (this.velocitySettings.smooth) {
                    adjusted.velocity = this.smoothVelocity(adjusted.velocity);
                }

                return adjusted;
            }

            smoothVelocity(velocity) {
                // ÂÆûÁé∞ÈÄüÂ∫¶Âπ≥ÊªëÁÆóÊ≥ï
                if (!this.velocityHistory) {
                    this.velocityHistory = [];
                }

                this.velocityHistory.push(velocity);
                if (this.velocityHistory.length > 5) {
                    this.velocityHistory.shift();
                }

                return this.velocityHistory.reduce((a, b) => a + b) / this.velocityHistory.length;
            }

            applyWetEdges() {
                // ÂÆûÁé∞ÊπøËæπÊïàÊûú
                // ËøôÈáåÂèØ‰ª•ÂÆûÁé∞Ê∞¥ÂΩ©ÁîªÁöÑËæπÁºòÁßØÁ¥ØÊïàÊûú
            }

            loadPreset(preset) {
                this.size = preset.size || 10;
                this.hardness = preset.hardness || 1;

                // Êõ¥Êñ∞UI
                document.getElementById('brushSizeSlider').value = this.size;
                document.getElementById('brushSizeValue').textContent = this.size + 'px';
                document.getElementById('brushHardnessSlider').value = this.hardness * 100;
                document.getElementById('brushHardnessValue').textContent = Math.round(this.hardness * 100) + '%';

                // Â∫îÁî®È¢ÑËÆæÁâπÊúâËÆæÁΩÆ
                switch (preset.type) {
                    case 'watercolor':
                        this.wetness = 0.7;
                        this.bleedAmount = 0.3;
                        this.setTexture('watercolor');
                        break;
                    case 'oil':
                        this.wetness = 0.3;
                        this.setTexture('canvas');
                        break;
                    case 'pencil':
                        this.setTexture('paper');
                        this.pressureSettings.size = true;
                        this.pressureSettings.opacity = true;
                        break;
                    // ... ÂÖ∂‰ªñÈ¢ÑËÆæ
                }
            }

            setSize(size) {
                this.size = parseInt(size);
                this.app.updateCursor();
            }

            setHardness(hardness) {
                this.hardness = hardness;
            }

            setFlow(flow) {
                this.flow = flow;
            }

            setSpacing(spacing) {
                this.spacing = spacing;
            }

            increaseSize() {
                this.setSize(Math.min(500, this.size + 5));
                document.getElementById('brushSizeSlider').value = this.size;
                document.getElementById('brushSizeValue').textContent = this.size + 'px';
            }

            decreaseSize() {
                this.setSize(Math.max(1, this.size - 5));
                document.getElementById('brushSizeSlider').value = this.size;
                document.getElementById('brushSizeValue').textContent = this.size + 'px';
            }
        }

        // ÂõæÂ±ÇÁÆ°ÁêÜÂô®
        class LayerManager {
            constructor(app) {
                this.app = app;
                this.layers = [];
                this.activeLayerIndex = 0;

                // ÂàõÂª∫ÈªòËÆ§ÂõæÂ±Ç
                this.addLayer('ËÉåÊôØ');
            }

            initUI() {
                // Ê∑ªÂä†ÂõæÂ±ÇÊåâÈíÆ
                document.getElementById('addLayerBtn').addEventListener('click', () => {
                    this.addLayer(`ÂõæÂ±Ç ${this.layers.length + 1}`);
                });

                // Ê∑∑ÂêàÊ®°Âºè
                document.getElementById('blendModeSelect').addEventListener('change', (e) => {
                    this.setBlendMode(e.target.value);
                });

                // ‰∏çÈÄèÊòéÂ∫¶
                document.getElementById('layerOpacitySlider').addEventListener('input', (e) => {
                    this.setOpacity(e.target.value / 100);
                    document.getElementById('layerOpacityValue').textContent = e.target.value + '%';
                });

                this.updateLayersPanel();
            }

            addLayer(name) {
                const canvas = document.createElement('canvas');
                canvas.width = this.app.canvas.width;
                canvas.height = this.app.canvas.height;

                const layer = {
                    id: Date.now(),
                    name: name,
                    canvas: canvas,
                    ctx: canvas.getContext('2d'),
                    visible: true,
                    opacity: 1,
                    blendMode: 'normal',
                    locked: false
                };

                this.layers.push(layer);
                this.activeLayerIndex = this.layers.length - 1;
                this.updateLayersPanel();

                return layer;
            }

            removeLayer(index) {
                if (this.layers.length > 1) {
                    this.layers.splice(index, 1);
                    this.activeLayerIndex = Math.min(this.activeLayerIndex, this.layers.length - 1);
                    this.updateLayersPanel();
                }
            }

            duplicateLayer(index) {
                const source = this.layers[index];
                const newLayer = this.addLayer(source.name + ' ÂâØÊú¨');

                // Â§çÂà∂ÁîªÂ∏ÉÂÜÖÂÆπ
                newLayer.ctx.drawImage(source.canvas, 0, 0);

                this.updateLayersPanel();
            }

            mergeDown(index) {
                if (index > 0) {
                    const upper = this.layers[index];
                    const lower = this.layers[index - 1];

                    // ÂêàÂπ∂ÂõæÂ±Ç
                    lower.ctx.save();
                    lower.ctx.globalAlpha = upper.opacity;
                    lower.ctx.globalCompositeOperation = upper.blendMode;
                    lower.ctx.drawImage(upper.canvas, 0, 0);
                    lower.ctx.restore();

                    // Âà†Èô§‰∏äÂ±Ç
                    this.removeLayer(index);
                }
            }

            setBlendMode(mode) {
                const layer = this.layers[this.activeLayerIndex];
                if (layer) {
                    layer.blendMode = mode;
                    this.renderComposite();
                }
            }

            setOpacity(opacity) {
                const layer = this.layers[this.activeLayerIndex];
                if (layer) {
                    layer.opacity = opacity;
                    this.renderComposite();
                }
            }

            toggleVisibility(index) {
                this.layers[index].visible = !this.layers[index].visible;
                this.renderComposite();
            }

            toggleLock(index) {
                this.layers[index].locked = !this.layers[index].locked;
                this.updateLayersPanel();
            }

            selectLayer(index) {
                this.activeLayerIndex = index;
                this.updateLayersPanel();

                // ÂàáÊç¢ÁªòÂà∂‰∏ä‰∏ãÊñáÂà∞ÂΩìÂâçÂõæÂ±Ç
                this.app.ctx = this.layers[index].ctx;
            }

            updateLayersPanel() {
                const panel = document.getElementById('layersPanel');
                panel.innerHTML = '';

                // ‰ªé‰∏äÂà∞‰∏ãÊòæÁ§∫ÂõæÂ±ÇÔºàÊï∞ÁªÑÂèçÂêëÔºâ
                [...this.layers].reverse().forEach((layer, reverseIndex) => {
                    const index = this.layers.length - 1 - reverseIndex;
                    const div = document.createElement('div');
                    div.className = 'layer-item';
                    if (index === this.activeLayerIndex) {
                        div.classList.add('active');
                    }

                    // Áº©Áï•Âõæ
                    const thumbnail = document.createElement('canvas');
                    thumbnail.className = 'layer-thumbnail';
                    thumbnail.width = 40;
                    thumbnail.height = 40;
                    const thumbCtx = thumbnail.getContext('2d');
                    thumbCtx.drawImage(layer.canvas, 0, 0, 40, 40);

                    // ÂõæÂ±Ç‰ø°ÊÅØ
                    const info = document.createElement('div');
                    info.className = 'layer-info';
                    info.innerHTML = `
                        <div class="layer-name">${layer.name}</div>
                        <div class="layer-opacity">${Math.round(layer.opacity * 100)}%</div>
                    `;

                    // ÊéßÂà∂ÊåâÈíÆ
                    const controls = document.createElement('div');
                    controls.className = 'layer-controls';

                    const visBtn = document.createElement('button');
                    visBtn.className = 'layer-control-btn';
                    visBtn.innerHTML = layer.visible ? 'üëÅÔ∏è' : 'üëÅÔ∏è‚Äçüó®Ô∏è';
                    visBtn.onclick = () => this.toggleVisibility(index);

                    const lockBtn = document.createElement('button');
                    lockBtn.className = 'layer-control-btn';
                    lockBtn.innerHTML = layer.locked ? 'üîí' : 'üîì';
                    lockBtn.onclick = () => this.toggleLock(index);

                    controls.appendChild(visBtn);
                    controls.appendChild(lockBtn);

                    div.appendChild(thumbnail);
                    div.appendChild(info);
                    div.appendChild(controls);

                    div.onclick = (e) => {
                        if (!e.target.classList.contains('layer-control-btn')) {
                            this.selectLayer(index);
                        }
                    };

                    panel.appendChild(div);
                });

                // Êõ¥Êñ∞ÂõæÂ±ÇÊï∞ÈáèÊòæÁ§∫
                document.getElementById('layerCount').textContent = this.layers.length;
            }

            updateThumbnails() {
                // Êõ¥Êñ∞ÊâÄÊúâÂõæÂ±ÇÁº©Áï•Âõæ
                this.updateLayersPanel();
            }

            renderComposite() {
                // ÂêàÊàêÊâÄÊúâÂèØËßÅÂõæÂ±ÇÂà∞‰∏ªÁîªÂ∏É
                const mainCtx = this.app.canvas.getContext('2d');
                mainCtx.clearRect(0, 0, this.app.canvas.width, this.app.canvas.height);

                this.layers.forEach(layer => {
                    if (layer.visible) {
                        mainCtx.save();
                        mainCtx.globalAlpha = layer.opacity;
                        mainCtx.globalCompositeOperation = layer.blendMode;
                        mainCtx.drawImage(layer.canvas, 0, 0);
                        mainCtx.restore();
                    }
                });
            }

            renderAllLayers(ctx) {
                // Ê∏≤ÊüìÊâÄÊúâÂõæÂ±ÇÂà∞ÊåáÂÆö‰∏ä‰∏ãÊñáÔºàÁî®‰∫éÂØºÂá∫Ôºâ
                this.layers.forEach(layer => {
                    if (layer.visible) {
                        ctx.save();
                        ctx.globalAlpha = layer.opacity;
                        ctx.globalCompositeOperation = layer.blendMode;
                        ctx.drawImage(layer.canvas, 0, 0);
                        ctx.restore();
                    }
                });
            }

            clear() {
                this.layers = [];
                this.addLayer('ËÉåÊôØ');
                this.updateLayersPanel();
            }

            exportLayers() {
                // ÂØºÂá∫ÂõæÂ±ÇÊï∞ÊçÆ
                return this.layers.map(layer => ({
                    name: layer.name,
                    visible: layer.visible,
                    opacity: layer.opacity,
                    blendMode: layer.blendMode,
                    locked: layer.locked,
                    data: layer.canvas.toDataURL()
                }));
            }
        }

        // È¢úËâ≤Á≥ªÁªü
        class ColorSystem {
            constructor(app) {
                this.app = app;
                this.currentColor = { r: 255, g: 107, b: 107 };
                this.colorMode = 'rgb';
                this.recentColors = [];
                this.palette = [];

                this.initColorWheel();
            }

            initUI() {
                // È¢úËâ≤Ê®°ÂºèÂàáÊç¢
                document.querySelectorAll('.color-mode-tab').forEach(tab => {
                    tab.addEventListener('click', () => {
                        this.setColorMode(tab.dataset.mode);
                        document.querySelectorAll('.color-mode-tab').forEach(t => t.classList.remove('active'));
                        tab.classList.add('active');
                    });
                });

                // RGBËæìÂÖ•
                ['R', 'G', 'B'].forEach(channel => {
                    document.getElementById(`color${channel}`).addEventListener('input', (e) => {
                        this.currentColor[channel.toLowerCase()] = parseInt(e.target.value);
                        this.updateColorDisplay();
                    });
                });

                // ÂàùÂßãÂåñÊúÄËøëÈ¢úËâ≤ÂíåËâ≤Êùø
                this.updateRecentColors();
                this.loadDefaultPalette();
            }

            initColorWheel() {
                const canvas = document.getElementById('colorWheel');
                const ctx = canvas.getContext('2d');
                canvas.width = 200;
                canvas.height = 200;

                // ÁªòÂà∂Ëâ≤ËΩÆ
                const centerX = canvas.width / 2;
                const centerY = canvas.height / 2;
                const radius = 90;

                for (let angle = 0; angle < 360; angle += 1) {
                    const startAngle = (angle - 1) * Math.PI / 180;
                    const endAngle = angle * Math.PI / 180;

                    for (let r = 0; r < radius; r += 1) {
                        const saturation = r / radius;
                        ctx.beginPath();
                        ctx.arc(centerX, centerY, r, startAngle, endAngle);
                        ctx.strokeStyle = `hsl(${angle}, ${saturation * 100}%, 50%)`;
                        ctx.lineWidth = 2;
                        ctx.stroke();
                    }
                }

                // Ëâ≤ËΩÆ‰∫§‰∫í
                canvas.addEventListener('click', (e) => {
                    const rect = canvas.getBoundingClientRect();
                    const x = e.clientX - rect.left - centerX;
                    const y = e.clientY - rect.top - centerY;

                    const angle = Math.atan2(y, x) * 180 / Math.PI + 180;
                    const distance = Math.sqrt(x * x + y * y);
                    const saturation = Math.min(distance / radius, 1);

                    this.setHSL(angle, saturation, 0.5);
                });
            }

            setColorMode(mode) {
                this.colorMode = mode;
                this.updateColorInputs();
            }

            updateColorInputs() {
                // Ê†πÊçÆÈ¢úËâ≤Ê®°ÂºèÊõ¥Êñ∞ËæìÂÖ•Ê°Ü
                // ËøôÈáåÂèØ‰ª•Ê†πÊçÆ‰∏çÂêåÊ®°ÂºèÊòæÁ§∫‰∏çÂêåÁöÑËæìÂÖ•Ê°Ü
            }

            setHSL(h, s, l) {
                // HSLËΩ¨RGB
                const c = (1 - Math.abs(2 * l - 1)) * s;
                const x = c * (1 - Math.abs((h / 60) % 2 - 1));
                const m = l - c / 2;

                let r, g, b;
                if (h < 60) {
                    [r, g, b] = [c, x, 0];
                } else if (h < 120) {
                    [r, g, b] = [x, c, 0];
                } else if (h < 180) {
                    [r, g, b] = [0, c, x];
                } else if (h < 240) {
                    [r, g, b] = [0, x, c];
                } else if (h < 300) {
                    [r, g, b] = [x, 0, c];
                } else {
                    [r, g, b] = [c, 0, x];
                }

                this.currentColor = {
                    r: Math.round((r + m) * 255),
                    g: Math.round((g + m) * 255),
                    b: Math.round((b + m) * 255)
                };

                this.updateColorDisplay();
            }

            updateColorDisplay() {
                // Êõ¥Êñ∞È¢úËâ≤ÊòæÁ§∫
                document.getElementById('colorR').value = this.currentColor.r;
                document.getElementById('colorG').value = this.currentColor.g;
                document.getElementById('colorB').value = this.currentColor.b;

                // Ê∑ªÂä†Âà∞ÊúÄËøë‰ΩøÁî®
                this.addToRecentColors(this.currentColor);
            }

            addToRecentColors(color) {
                const colorStr = `rgb(${color.r},${color.g},${color.b})`;

                // ÁßªÈô§ÈáçÂ§çÁöÑ
                this.recentColors = this.recentColors.filter(c => c !== colorStr);

                // Ê∑ªÂä†Âà∞ÂºÄÂ§¥
                this.recentColors.unshift(colorStr);

                // ÈôêÂà∂Êï∞Èáè
                if (this.recentColors.length > 16) {
                    this.recentColors.pop();
                }

                this.updateRecentColors();
            }

            updateRecentColors() {
                const container = document.getElementById('recentColors');
                container.innerHTML = '';

                this.recentColors.forEach(color => {
                    const div = document.createElement('div');
                    div.style.width = '20px';
                    div.style.height = '20px';
                    div.style.backgroundColor = color;
                    div.style.border = '1px solid #dee2e6';
                    div.style.borderRadius = '4px';
                    div.style.cursor = 'pointer';

                    div.onclick = () => {
                        const rgb = color.match(/\d+/g);
                        this.currentColor = {
                            r: parseInt(rgb[0]),
                            g: parseInt(rgb[1]),
                            b: parseInt(rgb[2])
                        };
                        this.updateColorDisplay();
                    };

                    container.appendChild(div);
                });
            }

            loadDefaultPalette() {
                // Âä†ËΩΩÈªòËÆ§Ëâ≤Êùø
                const defaultColors = [
                    '#000000', '#FFFFFF', '#FF0000', '#00FF00',
                    '#0000FF', '#FFFF00', '#FF00FF', '#00FFFF',
                    '#800000', '#008000', '#000080', '#808000',
                    '#800080', '#008080', '#C0C0C0', '#808080'
                ];

                const container = document.getElementById('colorPalette');
                container.innerHTML = '';

                defaultColors.forEach(color => {
                    const div = document.createElement('div');
                    div.style.width = '20px';
                    div.style.height = '20px';
                    div.style.backgroundColor = color;
                    div.style.border = '1px solid #dee2e6';
                    div.style.borderRadius = '4px';
                    div.style.cursor = 'pointer';

                    div.onclick = () => {
                        const hex = color.substring(1);
                        this.currentColor = {
                            r: parseInt(hex.substring(0, 2), 16),
                            g: parseInt(hex.substring(2, 4), 16),
                            b: parseInt(hex.substring(4, 6), 16)
                        };
                        this.updateColorDisplay();
                    };

                    container.appendChild(div);
                });
            }

            pickColor(point) {
                // ‰ªéÁîªÂ∏ÉÊãæÂèñÈ¢úËâ≤
                const imageData = this.app.ctx.getImageData(point.x, point.y, 1, 1);
                const data = imageData.data;

                this.currentColor = {
                    r: data[0],
                    g: data[1],
                    b: data[2]
                };

                this.updateColorDisplay();
            }

            getCurrentColor() {
                return this.currentColor;
            }
        }

        // ÂéÜÂè≤ÁÆ°ÁêÜÂô®
        class HistoryManager {
            constructor(app) {
                this.app = app;
                this.history = [];
                this.currentIndex = -1;
                this.maxHistory = Infinity;  // Êó†ÈôêÂéÜÂè≤ËÆ∞ÂΩï
            }

            initUI() {
                // Êí§ÈîÄ/ÈáçÂÅöÊåâÈíÆ
                document.getElementById('undoBtn').addEventListener('click', () => this.undo());
                document.getElementById('redoBtn').addEventListener('click', () => this.redo());

                this.updateUI();
            }

            saveState() {
                // ‰øùÂ≠òÂΩìÂâçÁä∂ÊÄÅ
                const state = {
                    timestamp: Date.now(),
                    action: this.getCurrentAction(),
                    layers: this.app.layerManager.exportLayers(),
                    thumbnail: this.createThumbnail()
                };

                // Â¶ÇÊûú‰∏çÂú®ÂéÜÂè≤Êú´Â∞æÔºåÂà†Èô§ÂêéÈù¢ÁöÑÂéÜÂè≤
                if (this.currentIndex < this.history.length - 1) {
                    this.history = this.history.slice(0, this.currentIndex + 1);
                }

                // Ê∑ªÂä†Êñ∞Áä∂ÊÄÅ
                this.history.push(state);
                this.currentIndex++;

                // ÈôêÂà∂ÂéÜÂè≤Êï∞ÈáèÔºàÂ¶ÇÊûúÈúÄË¶ÅÔºâ
                if (this.maxHistory !== Infinity && this.history.length > this.maxHistory) {
                    this.history.shift();
                    this.currentIndex--;
                }

                this.updateUI();
                this.updateTimeline();
            }

            undo() {
                if (this.currentIndex > 0) {
                    this.currentIndex--;
                    this.restoreState(this.history[this.currentIndex]);
                    this.updateUI();
                    this.updateTimeline();
                }
            }

            redo() {
                if (this.currentIndex < this.history.length - 1) {
                    this.currentIndex++;
                    this.restoreState(this.history[this.currentIndex]);
                    this.updateUI();
                    this.updateTimeline();
                }
            }

            restoreState(state) {
                // ÊÅ¢Â§çÁä∂ÊÄÅ
                // ËøôÈáåÈúÄË¶ÅÊÅ¢Â§çÂõæÂ±ÇÊï∞ÊçÆ
                console.log('ÊÅ¢Â§çÁä∂ÊÄÅ:', state.action);
            }

            getCurrentAction() {
                // Ëé∑ÂèñÂΩìÂâçÊìç‰ΩúÊèèËø∞
                const tool = this.app.currentTool;
                const actions = {
                    'brush': 'ÁîªÁ¨îÁªòÂà∂',
                    'eraser': 'Êì¶Èô§',
                    'fill': 'Â°´ÂÖÖ',
                    'text': 'Ê∑ªÂä†ÊñáÂ≠ó',
                    // ...
                };
                return actions[tool] || 'Êìç‰Ωú';
            }

            createThumbnail() {
                // ÂàõÂª∫Áº©Áï•Âõæ
                const thumbCanvas = document.createElement('canvas');
                thumbCanvas.width = 30;
                thumbCanvas.height = 30;
                const ctx = thumbCanvas.getContext('2d');
                ctx.drawImage(this.app.canvas, 0, 0, 30, 30);
                return thumbCanvas.toDataURL();
            }

            updateUI() {
                // Êõ¥Êñ∞Êí§ÈîÄ/ÈáçÂÅöÊåâÈíÆÁä∂ÊÄÅ
                document.getElementById('undoBtn').disabled = this.currentIndex <= 0;
                document.getElementById('redoBtn').disabled = this.currentIndex >= this.history.length - 1;

                // Êõ¥Êñ∞ÂéÜÂè≤ËÆ°Êï∞
                document.getElementById('historyCount').textContent =
                    `${this.currentIndex + 1}/${this.maxHistory === Infinity ? '‚àû' : this.maxHistory}`;
            }

            updateTimeline() {
                // Êõ¥Êñ∞ÂéÜÂè≤Êó∂Èó¥ËΩ¥
                const timeline = document.getElementById('historyTimeline');
                timeline.innerHTML = '';

                // ÊòæÁ§∫ÊúÄËøëÁöÑÂéÜÂè≤ËÆ∞ÂΩï
                const start = Math.max(0, this.currentIndex - 5);
                const end = Math.min(this.history.length, this.currentIndex + 6);

                for (let i = start; i < end; i++) {
                    const state = this.history[i];
                    const div = document.createElement('div');
                    div.className = 'history-item';
                    if (i === this.currentIndex) {
                        div.classList.add('current');
                    }

                    const thumb = document.createElement('img');
                    thumb.className = 'history-thumbnail';
                    thumb.src = state.thumbnail;

                    const info = document.createElement('div');
                    info.className = 'history-info';
                    info.innerHTML = `
                        <div class="history-action">${state.action}</div>
                        <div class="history-time">${this.formatTime(state.timestamp)}</div>
                    `;

                    div.appendChild(thumb);
                    div.appendChild(info);

                    div.onclick = () => {
                        this.currentIndex = i;
                        this.restoreState(state);
                        this.updateUI();
                        this.updateTimeline();
                    };

                    timeline.appendChild(div);
                }
            }

            formatTime(timestamp) {
                const date = new Date(timestamp);
                return date.toLocaleTimeString('zh-CN', {
                    hour: '2-digit',
                    minute: '2-digit',
                    second: '2-digit'
                });
            }

            clear() {
                this.history = [];
                this.currentIndex = -1;
                this.updateUI();
                this.updateTimeline();
            }

            exportHistory() {
                return this.history.map(state => ({
                    timestamp: state.timestamp,
                    action: state.action
                }));
            }
        }

        // ÂØπÁß∞Â∑•ÂÖ∑
        class SymmetryTool {
            constructor(app) {
                this.app = app;
                this.mode = 'none';
                this.segments = 4;
                this.center = { x: 960, y: 540 };
            }

            setMode(mode) {
                this.mode = mode;
                this.updateOverlay();
            }

            setSegments(segments) {
                this.segments = segments;
                this.updateOverlay();
            }

            updateOverlay() {
                // Êõ¥Êñ∞ÂØπÁß∞ËæÖÂä©Á∫øÊòæÁ§∫
                // ...
            }

            applySymmetry(point, callback) {
                switch (this.mode) {
                    case 'horizontal':
                        callback(point);
                        callback({ x: this.center.x * 2 - point.x, y: point.y });
                        break;
                    case 'vertical':
                        callback(point);
                        callback({ x: point.x, y: this.center.y * 2 - point.y });
                        break;
                    case 'radial':
                        for (let i = 0; i < this.segments; i++) {
                            const angle = (Math.PI * 2 / this.segments) * i;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);

                            const dx = point.x - this.center.x;
                            const dy = point.y - this.center.y;

                            const newX = this.center.x + dx * cos - dy * sin;
                            const newY = this.center.y + dx * sin + dy * cos;

                            callback({ x: newX, y: newY });
                        }
                        break;
                    case 'kaleidoscope':
                        // ‰∏áËä±Á≠íÊ®°Âºè
                        for (let i = 0; i < this.segments; i++) {
                            const angle = (Math.PI * 2 / this.segments) * i;
                            const cos = Math.cos(angle);
                            const sin = Math.sin(angle);

                            const dx = point.x - this.center.x;
                            const dy = point.y - this.center.y;

                            // ÊóãËΩ¨
                            const rotX = this.center.x + dx * cos - dy * sin;
                            const rotY = this.center.y + dx * sin + dy * cos;
                            callback({ x: rotX, y: rotY });

                            // ÈïúÂÉè
                            const mirrorX = this.center.x + dx * cos + dy * sin;
                            const mirrorY = this.center.y - dx * sin + dy * cos;
                            callback({ x: mirrorX, y: mirrorY });
                        }
                        break;
                    default:
                        callback(point);
                }
            }
        }

        // ÈÄèËßÜÂ∑•ÂÖ∑
        class PerspectiveTool {
            constructor(app) {
                this.app = app;
                this.points = 1;
                this.vanishingPoints = [];
                this.gridDensity = 10;
                this.snapEnabled = true;
            }

            setPoints(points) {
                this.points = points;
                this.setupVanishingPoints();
                this.drawGrid();
            }

            setupVanishingPoints() {
                // ËÆæÁΩÆÁÅ≠ÁÇπ‰ΩçÁΩÆ
                switch (this.points) {
                    case 1:
                        this.vanishingPoints = [
                            { x: this.app.canvas.width / 2, y: this.app.canvas.height / 2 }
                        ];
                        break;
                    case 2:
                        this.vanishingPoints = [
                            { x: this.app.canvas.width * 0.2, y: this.app.canvas.height / 2 },
                            { x: this.app.canvas.width * 0.8, y: this.app.canvas.height / 2 }
                        ];
                        break;
                    case 3:
                        this.vanishingPoints = [
                            { x: this.app.canvas.width * 0.2, y: this.app.canvas.height / 2 },
                            { x: this.app.canvas.width * 0.8, y: this.app.canvas.height / 2 },
                            { x: this.app.canvas.width / 2, y: this.app.canvas.height * 0.1 }
                        ];
                        break;
                }
            }

            drawGrid() {
                const overlay = document.getElementById('perspectiveOverlay');
                const ctx = overlay.getContext('2d');

                overlay.width = this.app.canvas.width;
                overlay.height = this.app.canvas.height;

                ctx.clearRect(0, 0, overlay.width, overlay.height);
                ctx.strokeStyle = 'rgba(102, 126, 234, 0.3)';
                ctx.lineWidth = 1;

                // ÁªòÂà∂ÈÄèËßÜÁΩëÊ†º
                this.vanishingPoints.forEach(vp => {
                    // ‰ªéÁÅ≠ÁÇπÂèëÂá∫ÁöÑÂ∞ÑÁ∫ø
                    for (let i = 0; i <= this.gridDensity; i++) {
                        const angle = (Math.PI * 2 / this.gridDensity) * i;
                        const endX = vp.x + Math.cos(angle) * 2000;
                        const endY = vp.y + Math.sin(angle) * 2000;

                        ctx.beginPath();
                        ctx.moveTo(vp.x, vp.y);
                        ctx.lineTo(endX, endY);
                        ctx.stroke();
                    }
                });
            }

            snapToGrid(point) {
                if (!this.snapEnabled) {
                    return point;
                }

                // Âê∏ÈôÑÂà∞ÊúÄËøëÁöÑÈÄèËßÜÁ∫ø
                // ... ÂÆûÁé∞Âê∏ÈôÑÁÆóÊ≥ï

                return point;
            }
        }

        // ÂèòÊç¢Â∑•ÂÖ∑
        class TransformTool {
            constructor(app) {
                this.app = app;
                this.selection = null;
                this.transformMatrix = [1, 0, 0, 1, 0, 0];
            }

            startTransform(selection) {
                this.selection = selection;
                // ÊòæÁ§∫ÂèòÊç¢ÊéßÂà∂ÁÇπ
            }

            applyTransform(matrix) {
                // Â∫îÁî®ÂèòÊç¢Áü©Èòµ
                this.transformMatrix = matrix;
                this.redrawSelection();
            }

            redrawSelection() {
                // ÈáçÁªòÈÄâÂå∫ÂÜÖÂÆπ
            }
        }

        // ÊÄßËÉΩÁõëËßÜÂô®
        class PerformanceMonitor {
            constructor() {
                this.fps = 60;
                this.memory = 0;
                this.lastTime = performance.now();
                this.frames = 0;

                // ÂºÄÂßãÁõëÊéß
                this.startMonitoring();
            }

            startMonitoring() {
                setInterval(() => {
                    const now = performance.now();
                    const delta = now - this.lastTime;

                    this.fps = Math.round((this.frames * 1000) / delta);
                    this.frames = 0;
                    this.lastTime = now;

                    // ÂÜÖÂ≠ò‰ΩøÁî®ÔºàÂ¶ÇÊûúÊîØÊåÅÔºâ
                    if (performance.memory) {
                        this.memory = Math.round(performance.memory.usedJSHeapSize / 1048576);
                    }

                    this.updateDisplay();
                }, 1000);

                // Â∏ßËÆ°Êï∞
                const countFrame = () => {
                    this.frames++;
                    requestAnimationFrame(countFrame);
                };
                countFrame();
            }

            updateDisplay() {
                document.getElementById('fps').textContent = this.fps;
                document.getElementById('memory').textContent = this.memory;
            }
        }

        // ‰∫ëÁ´ØÂêåÊ≠•ÔºàÊ®°ÊãüÔºâ
        class CloudSync {
            constructor() {
                this.syncing = false;
                this.lastSync = Date.now();
            }

            async sync() {
                this.showSyncStatus('ÂêåÊ≠•‰∏≠...');
                this.syncing = true;

                // Ê®°ÊãüÂêåÊ≠•Âª∂Ëøü
                await new Promise(resolve => setTimeout(resolve, 1000 + Math.random() * 1000));

                this.syncing = false;
                this.lastSync = Date.now();
                this.showSyncStatus('Â∑≤ÂêåÊ≠•');

                setTimeout(() => {
                    this.hideSyncStatus();
                }, 2000);
            }

            showSyncStatus(message) {
                const status = document.getElementById('syncStatus');
                document.getElementById('syncMessage').textContent = message;
                status.classList.add('show');
            }

            hideSyncStatus() {
                const status = document.getElementById('syncStatus');
                status.classList.remove('show');
            }

            autoSync() {
                setInterval(() => {
                    if (!this.syncing && Date.now() - this.lastSync > 30000) {
                        this.sync();
                    }
                }, 5000);
            }
        }

        // ÂàùÂßãÂåñÂ∫îÁî®
        window.addEventListener('DOMContentLoaded', () => {
            const app = new DrawingApp();
            window.drawingApp = app;  // Êö¥Èú≤ÁªôÂÖ®Â±ÄÔºàÁî®‰∫éË∞ÉËØïÔºâ
        });
    </script>
</body>
</html>