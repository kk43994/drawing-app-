<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>Â∞èÊñ∞ÁöÑË∂ÖÁ∫ßÁîªÁîªÊùø Pro üñçÔ∏è</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --shinchan-red: #FF6B6B;
            --shinchan-yellow: #FFD93D;
            --shinchan-blue: #6BCF7F;
            --shinchan-pink: #FFB6C1;
            --shinchan-purple: #C589E8;
            --panel-bg: rgba(255, 255, 255, 0.98);
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            --radius: 20px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: "Comic Sans MS", "ÂæÆËΩØÈõÖÈªë", -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            touch-action: none;
            background: linear-gradient(135deg, #FFE5B4 0%, #FFB6C1 25%, #C3B1E1 50%, #B4E7CE 75%, #FFDAB9 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100vh;
            overscroll-behavior: none;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* È°∂ÈÉ®Ê†áÈ¢òÊ†è - Â∞èÊñ∞È£éÊ†º */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 2px 20px rgba(255, 107, 107, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 env(safe-area-inset-right, 20px) 0 env(safe-area-inset-left, 20px);
            z-index: 1000;
            transition: var(--transition);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(135deg, var(--shinchan-red), var(--shinchan-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .shinchan-avatar {
            width: 40px;
            height: 40px;
            background: var(--shinchan-yellow);
            border-radius: 50%;
            position: relative;
            animation: wiggle 3s infinite;
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }

        .shinchan-avatar::before {
            content: "üòä";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        /* ÁîªÂ∏ÉÂÆπÂô® */
        .canvas-container {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .canvas-wrapper {
            position: relative;
            background: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            max-width: 100%;
            max-height: 100%;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        canvas {
            display: block;
            border-radius: var(--radius);
            cursor: crosshair;
            touch-action: none;
        }

        /* Ëá™ÂÆö‰πâÁîªÁ¨îÂÖâÊ†á */
        .custom-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            transition: transform 0.1s ease;
        }

        .cursor-ring {
            border: 2px solid var(--shinchan-red);
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* Â∫ïÈÉ®Â∑•ÂÖ∑Ê†è - ÁÆÄÊ¥Å‰ΩÜÂçé‰∏Ω */
        .toolbar {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 0);
            left: 0;
            right: 0;
            height: 120px;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1);
            padding: 10px;
            z-index: 1000;
            transition: var(--transition);
        }

        .toolbar-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
        }

        .tool-row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* Â∑•ÂÖ∑ÊåâÈíÆ - ÂèØÁà±È£éÊ†º */
        .tool-btn {
            width: 50px;
            height: 50px;
            border: 2px solid transparent;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .tool-btn::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, var(--shinchan-yellow) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }

        .tool-btn:active::before {
            width: 100px;
            height: 100px;
        }

        .tool-btn:hover {
            transform: translateY(-3px) scale(1.1);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
            border-color: var(--shinchan-red);
        }

        .tool-btn.active {
            background: linear-gradient(135deg, var(--shinchan-yellow), var(--shinchan-pink));
            border-color: var(--shinchan-red);
            animation: toolActive 0.5s ease;
        }

        @keyframes toolActive {
            0% { transform: scale(1); }
            50% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(1); }
        }

        /* È¢úËâ≤ÈÄâÊã©Âô® - ÂΩ©ËôπÈ£éÊ†º */
        .color-picker-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .color-wheel-mini {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: conic-gradient(from 0deg, red, yellow, lime, cyan, blue, magenta, red);
            cursor: pointer;
            position: relative;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transition: var(--transition);
        }

        .color-wheel-mini:hover {
            transform: scale(1.1) rotate(180deg);
        }

        .current-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 3px solid white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* Á¨îÂà∑Â§ßÂ∞èÊªëÂùó - ÂèØÁà±È£éÊ†º */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0 10px;
        }

        .slider {
            -webkit-appearance: none;
            width: 120px;
            height: 8px;
            border-radius: 10px;
            background: linear-gradient(to right, var(--shinchan-blue), var(--shinchan-yellow), var(--shinchan-red));
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            border: 3px solid var(--shinchan-red);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: var(--transition);
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .size-preview {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .size-dot {
            background: var(--shinchan-red);
            border-radius: 50%;
            transition: var(--transition);
        }

        /* ‰æßËæπÈù¢Êùø - ÊªëÂá∫Âºè */
        .side-panel {
            position: fixed;
            top: 60px;
            right: -300px;
            width: 300px;
            bottom: 120px;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: -2px 0 20px rgba(0, 0, 0, 0.1);
            transition: var(--transition);
            z-index: 999;
            padding: 20px;
            overflow-y: auto;
        }

        .side-panel.open {
            right: 0;
        }

        .panel-toggle {
            position: fixed;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 80px;
            background: var(--panel-bg);
            border-radius: 20px 0 0 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 998;
            transition: var(--transition);
        }

        .panel-toggle:hover {
            transform: translateY(-50%) translateX(-5px);
        }

        /* ÂõæÂ±ÇÈù¢Êùø */
        .layers-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            color: var(--shinchan-red);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: white;
            border-radius: 10px;
            margin-bottom: 5px;
            cursor: pointer;
            transition: var(--transition);
        }

        .layer-item:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .layer-item.active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 182, 193, 0.2));
            border: 2px solid var(--shinchan-yellow);
        }

        /* Á¨îÂà∑È¢ÑËÆæ - Âç°ÁâáÈ£éÊ†º */
        .brush-presets {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .brush-preset {
            aspect-ratio: 1;
            background: white;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid transparent;
        }

        .brush-preset:hover {
            transform: scale(1.05);
            border-color: var(--shinchan-pink);
        }

        .brush-preset.active {
            background: linear-gradient(135deg, var(--shinchan-yellow), var(--shinchan-pink));
            animation: bounce 0.5s;
        }

        .brush-icon {
            font-size: 24px;
        }

        .brush-name {
            font-size: 10px;
            color: #666;
        }

        /* Â∞èÊñ∞ËØ≠Èü≥Ê∞îÊ≥° */
        .shinchan-bubble {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 15px 25px;
            border-radius: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            color: var(--shinchan-red);
            opacity: 0;
            pointer-events: none;
            transition: var(--transition);
            z-index: 1001;
        }

        .shinchan-bubble.show {
            opacity: 1;
            animation: bubblePop 0.5s ease;
        }

        @keyframes bubblePop {
            0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }

        .shinchan-bubble::before {
            content: "üé§ Â∞èÊñ∞ËØ¥Ôºö";
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: var(--shinchan-purple);
        }

        /* ÂéãÂäõÊåáÁ§∫Âô® */
        .pressure-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: none;
            z-index: 100;
            min-width: 120px;
        }

        .pressure-indicator.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .pressure-bar {
            width: 100%;
            height: 8px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }

        .pressure-fill {
            height: 100%;
            background: linear-gradient(to right, var(--shinchan-blue), var(--shinchan-yellow), var(--shinchan-red));
            width: 0%;
            transition: width 0.1s;
        }

        /* ÁâπÊïàÊåâÈíÆ */
        .effect-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--shinchan-purple), var(--shinchan-pink));
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
        }

        .effect-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(197, 137, 232, 0.4);
        }

        /* ÂìçÂ∫îÂºè‰ºòÂåñ */
        @media (max-width: 768px) {
            .header {
                height: 50px;
            }

            .logo {
                font-size: 14px;
            }

            .shinchan-avatar {
                width: 35px;
                height: 35px;
            }

            .canvas-container {
                top: 50px;
                bottom: 100px;
                padding: 10px;
            }

            .toolbar {
                height: 100px;
            }

            .tool-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }

            .slider {
                width: 80px;
            }

            .side-panel {
                width: 250px;
                right: -250px;
            }
        }

        /* iPad‰∏ìÂ±û‰ºòÂåñ */
        @supports (-webkit-touch-callout: none) {
            .toolbar {
                padding-bottom: env(safe-area-inset-bottom, 10px);
            }

            .tool-btn {
                -webkit-touch-callout: none;
            }

            .slider {
                height: 44px;
                min-height: 44px;
            }

            .slider::-webkit-slider-thumb {
                width: 32px;
                height: 32px;
            }
        }

        /* Âä†ËΩΩÂä®Áîª */
        .loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--shinchan-yellow), var(--shinchan-pink));
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }

        .loader.hide {
            opacity: 0;
            pointer-events: none;
        }

        .loader-content {
            text-align: center;
        }

        .loader-shinchan {
            font-size: 80px;
            animation: rotate 2s linear infinite;
        }

        @keyframes rotate {
            to { transform: rotate(360deg); }
        }

        .loader-text {
            color: white;
            font-size: 18px;
            margin-top: 20px;
            font-weight: bold;
        }

        /* ÊÄßËÉΩ‰ºòÂåñ */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important;
            }
        }

        /* ÊöóËâ≤Ê®°ÂºèÊîØÊåÅ */
        @media (prefers-color-scheme: dark) {
            :root {
                --panel-bg: rgba(30, 30, 30, 0.95);
            }

            body {
                background: linear-gradient(135deg, #2C3E50, #34495E, #2C3E50);
            }
        }

        /* Ëß¶Êë∏ÂèçÈ¶à */
        .touchable {
            position: relative;
            overflow: hidden;
        }

        .touchable::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .touchable:active::after {
            width: 200px;
            height: 200px;
        }
    </style>
</head>
<body>
    <!-- Âä†ËΩΩÂä®Áîª -->
    <div class="loader" id="loader">
        <div class="loader-content">
            <div class="loader-shinchan">üé®</div>
            <div class="loader-text">Â∞èÊñ∞Ê≠£Âú®ÂáÜÂ§áÁîªÂÖ∑...</div>
        </div>
    </div>

    <!-- Â§¥ÈÉ® -->
    <div class="header">
        <div class="logo">
            <div class="shinchan-avatar"></div>
            <span>Â∞èÊñ∞ÁöÑË∂ÖÁ∫ßÁîªÁîªÊùø</span>
        </div>
        <div style="display: flex; gap: 10px;">
            <button class="effect-btn" onclick="app.newCanvas()">Êñ∞Âª∫</button>
            <button class="effect-btn" onclick="app.saveImage()">‰øùÂ≠ò</button>
            <button class="effect-btn" onclick="app.togglePanel()">Â∑•ÂÖ∑</button>
        </div>
    </div>

    <!-- ÁîªÂ∏ÉÂÆπÂô® -->
    <div class="canvas-container">
        <div class="canvas-wrapper">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>

    <!-- Ëá™ÂÆö‰πâÂÖâÊ†á -->
    <div class="custom-cursor" id="customCursor" style="display: none;">
        <div class="cursor-ring" id="cursorRing"></div>
    </div>

    <!-- Â∞èÊñ∞ËØ≠Èü≥Ê∞îÊ≥° -->
    <div class="shinchan-bubble" id="shinchanBubble"></div>

    <!-- ÂéãÂäõÊåáÁ§∫Âô® -->
    <div class="pressure-indicator" id="pressureIndicator">
        <div style="font-size: 12px; font-weight: bold;">Apple Pencil</div>
        <div class="pressure-bar">
            <div class="pressure-fill" id="pressureFill"></div>
        </div>
        <div style="font-size: 10px; margin-top: 5px;">
            ÂéãÂäõ: <span id="pressureValue">0%</span>
        </div>
    </div>

    <!-- Â∫ïÈÉ®Â∑•ÂÖ∑Ê†è -->
    <div class="toolbar">
        <div class="toolbar-content">
            <!-- Á¨¨‰∏ÄË°åÔºö‰∏ªË¶ÅÂ∑•ÂÖ∑ -->
            <div class="tool-row">
                <button class="tool-btn active touchable" data-tool="brush" onclick="app.selectTool('brush')">‚úèÔ∏è</button>
                <button class="tool-btn touchable" data-tool="eraser" onclick="app.selectTool('eraser')">üßπ</button>
                <button class="tool-btn touchable" data-tool="fill" onclick="app.selectTool('fill')">ü™£</button>
                <button class="tool-btn touchable" data-tool="eyedropper" onclick="app.selectTool('eyedropper')">üíâ</button>
                <button class="tool-btn touchable" data-tool="shape" onclick="app.selectTool('shape')">‚≠ï</button>
                <button class="tool-btn touchable" data-tool="text" onclick="app.selectTool('text')">üìù</button>
                <button class="tool-btn touchable" onclick="app.undo()">‚Ü©Ô∏è</button>
                <button class="tool-btn touchable" onclick="app.redo()">‚Ü™Ô∏è</button>
                <button class="tool-btn touchable" onclick="app.clearCanvas()">üóëÔ∏è</button>
            </div>

            <!-- Á¨¨‰∫åË°åÔºöÈ¢úËâ≤ÂíåÂ§ßÂ∞è -->
            <div class="tool-row">
                <div class="color-picker-container">
                    <div class="color-wheel-mini" onclick="app.showColorPicker()">
                        <div class="current-color" id="currentColor"></div>
                    </div>
                </div>

                <div class="slider-container">
                    <span style="font-size: 12px;">Á≤óÁªÜ:</span>
                    <input type="range" class="slider" id="brushSize" min="1" max="100" value="5">
                    <div class="size-preview">
                        <div class="size-dot" id="sizeDot"></div>
                    </div>
                </div>

                <select style="padding: 8px; border-radius: 10px; border: 2px solid var(--shinchan-pink);" id="brushEffect">
                    <option value="normal">ÊôÆÈÄö</option>
                    <option value="watercolor">Ê∞¥ÂΩ©</option>
                    <option value="crayon">Ëú°Á¨î</option>
                    <option value="marker">È©¨ÂÖãÁ¨î</option>
                    <option value="spray">Âñ∑Èõæ</option>
                </select>
            </div>
        </div>
    </div>

    <!-- ‰æßËæπÈù¢Êùø -->
    <div class="side-panel" id="sidePanel">
        <!-- Á¨îÂà∑È¢ÑËÆæ -->
        <div class="section-title">
            <span>üñåÔ∏è</span>
            <span>Á¨îÂà∑Â∫ì</span>
        </div>
        <div class="brush-presets">
            <div class="brush-preset" data-brush="pencil">
                <div class="brush-icon">‚úèÔ∏è</div>
                <div class="brush-name">ÈìÖÁ¨î</div>
            </div>
            <div class="brush-preset" data-brush="pen">
                <div class="brush-icon">üñäÔ∏è</div>
                <div class="brush-name">Èí¢Á¨î</div>
            </div>
            <div class="brush-preset" data-brush="marker">
                <div class="brush-icon">üñçÔ∏è</div>
                <div class="brush-name">È©¨ÂÖãÁ¨î</div>
            </div>
            <div class="brush-preset" data-brush="watercolor">
                <div class="brush-icon">üé®</div>
                <div class="brush-name">Ê∞¥ÂΩ©</div>
            </div>
            <div class="brush-preset" data-brush="crayon">
                <div class="brush-icon">üñçÔ∏è</div>
                <div class="brush-name">Ëú°Á¨î</div>
            </div>
            <div class="brush-preset" data-brush="spray">
                <div class="brush-icon">üí®</div>
                <div class="brush-name">Âñ∑Êû™</div>
            </div>
        </div>

        <!-- ÂõæÂ±Ç -->
        <div class="layers-section">
            <div class="section-title">
                <span>üìö</span>
                <span>ÂõæÂ±Ç</span>
                <button style="margin-left: auto;" class="effect-btn" onclick="app.addLayer()">+</button>
            </div>
            <div id="layersList">
                <div class="layer-item active">
                    <span>üìÑ</span>
                    <span>ÂõæÂ±Ç 1</span>
                    <span style="margin-left: auto;">üëÅÔ∏è</span>
                </div>
            </div>
        </div>

        <!-- È´òÁ∫ßËÆæÁΩÆ -->
        <div class="section-title">
            <span>‚öôÔ∏è</span>
            <span>È´òÁ∫ßËÆæÁΩÆ</span>
        </div>
        <div style="display: flex; flex-direction: column; gap: 10px;">
            <label style="font-size: 12px;">
                <input type="checkbox" id="pressureEnabled" checked> ÂéãÂäõÊÑüÂ∫î
            </label>
            <label style="font-size: 12px;">
                <input type="checkbox" id="smoothingEnabled" checked> Á¨îËß¶Âπ≥Êªë
            </label>
            <label style="font-size: 12px;">
                <input type="checkbox" id="symmetryEnabled"> ÂØπÁß∞ÁªòÂà∂
            </label>
        </div>
    </div>

    <!-- Èù¢ÊùøÂàáÊç¢ÊåâÈíÆ -->
    <div class="panel-toggle" onclick="app.togglePanel()">
        <span>üé®</span>
    </div>

    <script>
        // Â∞èÊñ∞ÁöÑËØ≠Èü≥Â∫ì
        const shinchanVoices = {
            brush: ["Ë¶ÅÂºÄÂßãÁîªÁîªÂíØ~", "Âä®ÊÑüË∂Ö‰∫∫ÁîªÁ¨îÔºåÂèòË∫´ÔºÅ", "Â∞èÊñ∞Ë¶ÅÁîªÁæéÂ•≥ÂßêÂßê~"],
            eraser: ["Ê©°ÁöÆÊì¶Êì¶Êì¶~", "Êää‰∏çÂ•ΩÁúãÁöÑÈÉΩÊì¶ÊéâÔºÅ", "Â¶àÂ¶àÁöÑÊã≥Â§¥ÂÉèÊ©°ÁöÆÊì¶"],
            fill: ["ÂÄíÈ¢úÊñôÂíØ~", "ÂìóÂï¶Âï¶Â°´Êª°ÂÆÉÔºÅ", "ÂÉèÊ¥í‰∫ÜÊûúÊ±Å‰∏ÄÊ†∑"],
            clear: ["ÂÖ®ÈÉ®Ê∏ÖÁ©∫ÔºÅÈáçÊñ∞ÂºÄÂßãÔºÅ", "ÂìáÔºåÈÉΩÊ≤°‰∫Ü~", "Â¶àÂ¶àË¶ÅÁîüÊ∞î‰∫ÜÔºåËµ∂Á¥ßÊ∏ÖÁ©∫ÔºÅ"],
            save: ["‰øùÂ≠òÂ∞èÊñ∞ÁöÑÂ§ß‰ΩúÔºÅ", "Ë¶ÅÁªôÂ¶àÂ¶àÁúãÁúã~", "Âä®ÊÑüË∂Ö‰∫∫ËÆ§ËØÅ‰ΩúÂìÅÔºÅ"],
            undo: ["ÂïäÔºåÁîªÈîô‰∫ÜÔºåÈÄÄÂõûÂéªÔºÅ", "Êó∂ÂÖâÂÄíÊµÅÊúØÔºÅ", "Êí§ÈîÄÊí§ÈîÄ~"],
            redo: ["ÈáçÊñ∞ÂÅö‰∏ÄÈÅçÔºÅ", "ÂÜçÊù•‰∏ÄÊ¨°ÔºÅ", "Âä®ÊÑüÊÅ¢Â§çÊúØÔºÅ"]
        };

        class DrawingApp {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d', {
                    willReadFrequently: true,
                    alpha: true,
                    desynchronized: true
                });

                // ËÆæÁΩÆÁîªÂ∏É
                this.setupCanvas();

                // Â∑•ÂÖ∑Áä∂ÊÄÅ
                this.currentTool = 'brush';
                this.currentColor = '#FF6B6B';
                this.brushSize = 5;
                this.brushEffect = 'normal';
                this.isDrawing = false;
                this.lastPoint = null;

                // ÂéãÂäõÂíåÂÄæÊñú
                this.pressure = 1;
                this.tiltX = 0;
                this.tiltY = 0;
                this.velocity = 0;
                this.lastTime = 0;

                // ÂéÜÂè≤ËÆ∞ÂΩï
                this.history = [];
                this.historyStep = -1;

                // ÂõæÂ±ÇÁ≥ªÁªü
                this.layers = [];
                this.currentLayer = 0;

                // ËÆæÁΩÆ
                this.pressureEnabled = true;
                this.smoothingEnabled = true;
                this.symmetryEnabled = false;

                // ÂàùÂßãÂåñ
                this.init();
            }

            init() {
                // ÂàùÂßãÂåñ‰∫ã‰ª∂ÁõëÂê¨
                this.setupEventListeners();

                // ÂàùÂßãÂåñUI
                this.setupUI();

                // ‰øùÂ≠òÂàùÂßãÁä∂ÊÄÅ
                this.saveHistory();

                // ÈöêËóèÂä†ËΩΩÂä®Áîª
                setTimeout(() => {
                    document.getElementById('loader').classList.add('hide');
                    this.showShinchanVoice("Ê¨¢ËøéÊù•Âà∞Â∞èÊñ∞ÁöÑÁîªÁîª‰∏ñÁïåÔºÅ");
                }, 1000);
            }

            setupCanvas() {
                // ÂìçÂ∫îÂºèÁîªÂ∏ÉÂ§ßÂ∞è
                const container = document.querySelector('.canvas-container');
                const rect = container.getBoundingClientRect();

                // È´òDPIÊîØÊåÅ
                const dpr = window.devicePixelRatio || 1;

                // ËÆæÁΩÆÁîªÂ∏ÉÂ∞∫ÂØ∏
                const width = Math.min(rect.width - 40, 1024);
                const height = Math.min(rect.height - 40, 768);

                this.canvas.width = width * dpr;
                this.canvas.height = height * dpr;
                this.canvas.style.width = width + 'px';
                this.canvas.style.height = height + 'px';

                // Áº©Êîæ‰∏ä‰∏ãÊñá‰ª•ÂåπÈÖçËÆæÂ§áÂÉèÁ¥†ÊØî
                this.ctx.scale(dpr, dpr);

                // ËÆæÁΩÆÈªòËÆ§Ê†∑Âºè
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
            }

            setupEventListeners() {
                // Èº†Ê†á‰∫ã‰ª∂
                this.canvas.addEventListener('mousedown', this.handleStart.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleEnd.bind(this));
                this.canvas.addEventListener('mouseleave', this.handleEnd.bind(this));

                // Ëß¶Êë∏‰∫ã‰ª∂
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                this.canvas.addEventListener('touchcancel', this.handleTouchEnd.bind(this), { passive: false });

                // Pointer Events (ÊúÄ‰Ω≥ÊîØÊåÅApple Pencil)
                if (window.PointerEvent) {
                    this.canvas.addEventListener('pointerdown', this.handlePointerDown.bind(this));
                    this.canvas.addEventListener('pointermove', this.handlePointerMove.bind(this));
                    this.canvas.addEventListener('pointerup', this.handlePointerUp.bind(this));
                    this.canvas.addEventListener('pointercancel', this.handlePointerUp.bind(this));
                }

                // ÈòªÊ≠¢ÈªòËÆ§Ëß¶Êë∏Ë°å‰∏∫
                this.canvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
                document.addEventListener('touchmove', e => {
                    if (e.target === this.canvas) e.preventDefault();
                }, { passive: false });

                // Á™óÂè£Ë∞ÉÊï¥
                window.addEventListener('resize', this.handleResize.bind(this));

                // ÈîÆÁõòÂø´Êç∑ÈîÆ
                document.addEventListener('keydown', this.handleKeyDown.bind(this));
            }

            setupUI() {
                // È¢úËâ≤ÈÄâÊã©
                document.getElementById('currentColor').style.background = this.currentColor;

                // ÁîªÁ¨îÂ§ßÂ∞è
                const sizeSlider = document.getElementById('brushSize');
                sizeSlider.addEventListener('input', (e) => {
                    this.brushSize = e.target.value;
                    this.updateSizePreview();
                    this.updateCursor();
                });

                // ÁîªÁ¨îÊïàÊûú
                document.getElementById('brushEffect').addEventListener('change', (e) => {
                    this.brushEffect = e.target.value;
                    this.showShinchanVoice(`ÂàáÊç¢Âà∞${e.target.selectedOptions[0].text}Ê®°ÂºèÔºÅ`);
                });

                // ËÆæÁΩÆÈÄâÈ°π
                document.getElementById('pressureEnabled').addEventListener('change', (e) => {
                    this.pressureEnabled = e.target.checked;
                });

                document.getElementById('smoothingEnabled').addEventListener('change', (e) => {
                    this.smoothingEnabled = e.target.checked;
                });

                document.getElementById('symmetryEnabled').addEventListener('change', (e) => {
                    this.symmetryEnabled = e.target.checked;
                });

                // Á¨îÂà∑È¢ÑËÆæ
                document.querySelectorAll('.brush-preset').forEach(preset => {
                    preset.addEventListener('click', () => {
                        this.selectBrushPreset(preset.dataset.brush);
                        document.querySelectorAll('.brush-preset').forEach(p => p.classList.remove('active'));
                        preset.classList.add('active');
                    });
                });

                // ÂàùÂßãÂåñ
                this.updateSizePreview();
                this.updateCursor();
            }

            // Pointer EventsÂ§ÑÁêÜÔºàÊúÄ‰ºòÂÖàÔºåÊîØÊåÅApple PencilÔºâ
            handlePointerDown(e) {
                if (e.pointerType === 'pen' || e.pointerType === 'touch' || e.pointerType === 'mouse') {
                    this.pressure = e.pressure || 1;
                    this.tiltX = e.tiltX || 0;
                    this.tiltY = e.tiltY || 0;

                    // ÊòæÁ§∫ÂéãÂäõÊåáÁ§∫Âô®
                    if (e.pointerType === 'pen' && e.pressure) {
                        this.showPressureIndicator();
                        this.updatePressure(e.pressure);
                    }

                    const point = this.getPoint(e);
                    this.startDrawing(point);
                }
            }

            handlePointerMove(e) {
                if (e.pointerType === 'pen' || e.pointerType === 'touch' || e.pointerType === 'mouse') {
                    this.pressure = e.pressure || 1;
                    this.tiltX = e.tiltX || 0;
                    this.tiltY = e.tiltY || 0;

                    if (e.pointerType === 'pen' && e.pressure) {
                        this.updatePressure(e.pressure);
                    }

                    const point = this.getPoint(e);
                    this.continueDrawing(point);
                    this.updateCursorPosition(e);
                }
            }

            handlePointerUp(e) {
                this.stopDrawing();
                this.hidePressureIndicator();
            }

            // Ëß¶Êë∏‰∫ã‰ª∂Â§ÑÁêÜÔºàÂ§áÁî®Ôºâ
            handleTouchStart(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    // Ê£ÄÊµãApple Pencil
                    if (touch.force !== undefined) {
                        this.pressure = touch.force;
                        this.showPressureIndicator();
                        this.updatePressure(touch.force);
                    }

                    if (touch.altitudeAngle !== undefined) {
                        // iPadÁâπÊúâÁöÑÂÄæÊñúËßíÂ∫¶
                        const altitude = touch.altitudeAngle;
                        const azimuth = touch.azimuthAngle;
                        this.tiltX = Math.cos(azimuth) * (90 - altitude * 180 / Math.PI);
                        this.tiltY = Math.sin(azimuth) * (90 - altitude * 180 / Math.PI);
                    }

                    const point = this.getPoint(touch);
                    this.startDrawing(point);
                }
            }

            handleTouchMove(e) {
                e.preventDefault();
                if (e.touches.length === 1 && this.isDrawing) {
                    const touch = e.touches[0];
                    if (touch.force !== undefined) {
                        this.pressure = touch.force;
                        this.updatePressure(touch.force);
                    }

                    const point = this.getPoint(touch);
                    this.continueDrawing(point);
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                this.stopDrawing();
                this.hidePressureIndicator();
            }

            // Èº†Ê†á‰∫ã‰ª∂Â§ÑÁêÜÔºàÊúÄ‰Ωé‰ºòÂÖàÁ∫ßÔºâ
            handleStart(e) {
                // Â¶ÇÊûúÂ∑≤ÁªèÊúâPointerÊàñTouch‰∫ã‰ª∂Â§ÑÁêÜÔºåÂàôÂøΩÁï•Èº†Ê†á‰∫ã‰ª∂
                if (!window.PointerEvent) {
                    const point = this.getPoint(e);
                    this.startDrawing(point);
                }
            }

            handleMove(e) {
                if (!window.PointerEvent) {
                    const point = this.getPoint(e);
                    this.continueDrawing(point);
                    this.updateCursorPosition(e);
                }
            }

            handleEnd(e) {
                if (!window.PointerEvent) {
                    this.stopDrawing();
                }
            }

            getPoint(e) {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                // Â§ÑÁêÜ‰∏çÂêåÁ±ªÂûãÁöÑ‰∫ã‰ª∂
                let clientX, clientY;
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                return {
                    x: (clientX - rect.left) * (this.canvas.width / dpr / rect.width),
                    y: (clientY - rect.top) * (this.canvas.height / dpr / rect.height)
                };
            }

            startDrawing(point) {
                this.isDrawing = true;
                this.lastPoint = point;
                this.lastTime = performance.now();

                // Ê†πÊçÆÂ∑•ÂÖ∑ÊâßË°åÊìç‰Ωú
                if (this.currentTool === 'eyedropper') {
                    this.pickColor(point);
                    return;
                }

                if (this.currentTool === 'fill') {
                    this.fillArea(point);
                    this.saveHistory();
                    return;
                }

                // ÂºÄÂßãÁªòÂà∂Ë∑ØÂæÑ
                this.ctx.beginPath();
                this.ctx.moveTo(point.x, point.y);
            }

            continueDrawing(point) {
                if (!this.isDrawing) return;

                if (this.currentTool === 'eyedropper') return;

                // ËÆ°ÁÆóÈÄüÂ∫¶
                const now = performance.now();
                const dt = now - this.lastTime;
                if (this.lastPoint && dt > 0) {
                    const distance = Math.sqrt(
                        Math.pow(point.x - this.lastPoint.x, 2) +
                        Math.pow(point.y - this.lastPoint.y, 2)
                    );
                    this.velocity = distance / dt;
                }
                this.lastTime = now;

                // Â∫îÁî®Âπ≥Êªë
                if (this.smoothingEnabled && this.lastPoint) {
                    point = this.smoothPoint(this.lastPoint, point);
                }

                // ÁªòÂà∂
                this.drawStroke(this.lastPoint, point);

                // ÂØπÁß∞ÁªòÂà∂
                if (this.symmetryEnabled) {
                    this.drawSymmetry(this.lastPoint, point);
                }

                this.lastPoint = point;
            }

            stopDrawing() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    this.lastPoint = null;

                    // ‰øùÂ≠òÂéÜÂè≤
                    if (this.currentTool !== 'eyedropper') {
                        this.saveHistory();
                    }
                }
            }

            drawStroke(from, to) {
                const ctx = this.ctx;

                // ËÆæÁΩÆÊ†∑Âºè
                this.setupBrushStyle();

                // ËÆ°ÁÆóÂÆûÈôÖÂ§ßÂ∞èÔºàÂ∫îÁî®ÂéãÂäõÔºâ
                let size = this.brushSize;
                if (this.pressureEnabled) {
                    size *= (0.3 + this.pressure * 0.7);
                }

                // Ê†πÊçÆÊïàÊûúÁªòÂà∂
                switch (this.brushEffect) {
                    case 'watercolor':
                        this.drawWatercolor(from, to, size);
                        break;
                    case 'crayon':
                        this.drawCrayon(from, to, size);
                        break;
                    case 'marker':
                        this.drawMarker(from, to, size);
                        break;
                    case 'spray':
                        this.drawSpray(from, to, size);
                        break;
                    default:
                        // ÊôÆÈÄöÁîªÁ¨î
                        ctx.lineWidth = size;
                        ctx.strokeStyle = this.currentTool === 'eraser' ? 'white' : this.currentColor;
                        ctx.globalCompositeOperation = this.currentTool === 'eraser' ? 'destination-out' : 'source-over';

                        ctx.beginPath();
                        ctx.moveTo(from.x, from.y);
                        ctx.lineTo(to.x, to.y);
                        ctx.stroke();
                }
            }

            drawWatercolor(from, to, size) {
                const ctx = this.ctx;
                ctx.globalAlpha = 0.1;
                ctx.strokeStyle = this.currentColor;
                ctx.lineWidth = size * 2;
                ctx.shadowBlur = size;
                ctx.shadowColor = this.currentColor;

                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.moveTo(from.x + Math.random() * 4 - 2, from.y + Math.random() * 4 - 2);
                    ctx.lineTo(to.x + Math.random() * 4 - 2, to.y + Math.random() * 4 - 2);
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }

            drawCrayon(from, to, size) {
                const ctx = this.ctx;
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = this.currentColor;

                for (let i = 0; i < 3; i++) {
                    ctx.lineWidth = size + Math.random() * 4;
                    ctx.beginPath();
                    ctx.moveTo(from.x + Math.random() * 2, from.y + Math.random() * 2);
                    ctx.lineTo(to.x + Math.random() * 2, to.y + Math.random() * 2);
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;
            }

            drawMarker(from, to, size) {
                const ctx = this.ctx;
                ctx.globalAlpha = 0.5;
                ctx.globalCompositeOperation = 'multiply';
                ctx.strokeStyle = this.currentColor;
                ctx.lineWidth = size * 2;
                ctx.lineCap = 'square';

                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.stroke();

                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineCap = 'round';
            }

            drawSpray(from, to, size) {
                const ctx = this.ctx;
                const distance = Math.sqrt(Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2));
                const steps = Math.max(1, Math.floor(distance));

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = from.x + (to.x - from.x) * t;
                    const y = from.y + (to.y - from.y) * t;

                    for (let j = 0; j < 20; j++) {
                        const offsetX = (Math.random() - 0.5) * size * 2;
                        const offsetY = (Math.random() - 0.5) * size * 2;
                        const radius = Math.random() * 2;

                        ctx.fillStyle = this.currentColor;
                        ctx.globalAlpha = 0.1;
                        ctx.beginPath();
                        ctx.arc(x + offsetX, y + offsetY, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.globalAlpha = 1;
            }

            drawSymmetry(from, to) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                // Ê∞¥Âπ≥ÂØπÁß∞
                const symFrom = { x: centerX * 2 - from.x, y: from.y };
                const symTo = { x: centerX * 2 - to.x, y: to.y };
                this.drawStroke(symFrom, symTo);

                // ÂûÇÁõ¥ÂØπÁß∞
                const symFromV = { x: from.x, y: centerY * 2 - from.y };
                const symToV = { x: to.x, y: centerY * 2 - to.y };
                this.drawStroke(symFromV, symToV);

                // ÂØπËßíÂØπÁß∞
                const symFromD = { x: centerX * 2 - from.x, y: centerY * 2 - from.y };
                const symToD = { x: centerX * 2 - to.x, y: centerY * 2 - to.y };
                this.drawStroke(symFromD, symToD);
            }

            smoothPoint(from, to) {
                const smoothing = 0.5;
                return {
                    x: from.x + (to.x - from.x) * (1 - smoothing),
                    y: from.y + (to.y - from.y) * (1 - smoothing)
                };
            }

            setupBrushStyle() {
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.imageSmoothingEnabled = true;
            }

            pickColor(point) {
                const imageData = this.ctx.getImageData(point.x, point.y, 1, 1);
                const data = imageData.data;
                const r = data[0];
                const g = data[1];
                const b = data[2];

                this.currentColor = `rgb(${r},${g},${b})`;
                document.getElementById('currentColor').style.background = this.currentColor;
                this.showShinchanVoice("Âê∏Âèñ‰∫ÜËøô‰∏™È¢úËâ≤ÔºÅ");
            }

            fillArea(point) {
                // ÁÆÄÂçïÁöÑÂ°´ÂÖÖÂÆûÁé∞
                this.ctx.fillStyle = this.currentColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.showShinchanVoice("ÂìóÂï¶Âï¶ÔºåÂÖ®ÈÉ®Â°´Êª°‰∫ÜÔºÅ");
            }

            selectTool(tool) {
                this.currentTool = tool;

                // Êõ¥Êñ∞UI
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tool === tool);
                });

                // ÊòæÁ§∫Â∞èÊñ∞ËØ≠Èü≥
                if (shinchanVoices[tool]) {
                    const voices = shinchanVoices[tool];
                    const voice = voices[Math.floor(Math.random() * voices.length)];
                    this.showShinchanVoice(voice);
                }

                this.updateCursor();
            }

            selectBrushPreset(preset) {
                const presets = {
                    pencil: { size: 2, effect: 'normal', color: '#333333' },
                    pen: { size: 5, effect: 'normal', color: '#000000' },
                    marker: { size: 15, effect: 'marker', color: '#FF6B6B' },
                    watercolor: { size: 20, effect: 'watercolor', color: '#6BCF7F' },
                    crayon: { size: 10, effect: 'crayon', color: '#FFD93D' },
                    spray: { size: 30, effect: 'spray', color: '#C589E8' }
                };

                const p = presets[preset];
                if (p) {
                    this.brushSize = p.size;
                    this.brushEffect = p.effect;
                    this.currentColor = p.color;

                    // Êõ¥Êñ∞UI
                    document.getElementById('brushSize').value = p.size;
                    document.getElementById('brushEffect').value = p.effect;
                    document.getElementById('currentColor').style.background = p.color;

                    this.updateSizePreview();
                    this.updateCursor();

                    this.showShinchanVoice(`ÂàáÊç¢Âà∞${preset}ÔºÅ`);
                }
            }

            showColorPicker() {
                // ÁÆÄÂçïÁöÑÈ¢úËâ≤ÈÄâÊã©
                const colors = ['#FF6B6B', '#FFD93D', '#6BCF7F', '#6BCB7F', '#C589E8', '#000000', '#FFFFFF'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                this.currentColor = color;
                document.getElementById('currentColor').style.background = color;
                this.showShinchanVoice("Êç¢‰∏™È¢úËâ≤ÁîªÁîªÔºÅ");
            }

            updateSizePreview() {
                const dot = document.getElementById('sizeDot');
                const size = Math.min(this.brushSize, 30);
                dot.style.width = size + 'px';
                dot.style.height = size + 'px';
                dot.style.background = this.currentColor;
            }

            updateCursor() {
                const cursor = document.getElementById('customCursor');
                const ring = document.getElementById('cursorRing');

                if (this.currentTool === 'brush' || this.currentTool === 'eraser') {
                    cursor.style.display = 'block';
                    ring.style.width = this.brushSize + 'px';
                    ring.style.height = this.brushSize + 'px';
                    ring.style.borderColor = this.currentTool === 'eraser' ? '#FF6B6B' : this.currentColor;
                } else {
                    cursor.style.display = 'none';
                }
            }

            updateCursorPosition(e) {
                const cursor = document.getElementById('customCursor');
                if (cursor.style.display !== 'none') {
                    cursor.style.left = e.clientX + 'px';
                    cursor.style.top = e.clientY + 'px';
                }
            }

            showPressureIndicator() {
                document.getElementById('pressureIndicator').classList.add('show');
            }

            hidePressureIndicator() {
                setTimeout(() => {
                    document.getElementById('pressureIndicator').classList.remove('show');
                }, 1000);
            }

            updatePressure(pressure) {
                const percent = Math.round(pressure * 100);
                document.getElementById('pressureFill').style.width = percent + '%';
                document.getElementById('pressureValue').textContent = percent + '%';
            }

            showShinchanVoice(message) {
                const bubble = document.getElementById('shinchanBubble');
                bubble.textContent = message;
                bubble.classList.add('show');

                // ËØ≠Èü≥ÂêàÊàê
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(message);
                    utterance.lang = 'zh-CN';
                    utterance.rate = 1.2;
                    utterance.pitch = 1.5;
                    speechSynthesis.speak(utterance);
                }

                setTimeout(() => {
                    bubble.classList.remove('show');
                }, 3000);
            }

            saveHistory() {
                this.historyStep++;
                if (this.historyStep < this.history.length) {
                    this.history.length = this.historyStep;
                }
                this.history.push(this.canvas.toDataURL());

                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyStep--;
                }
            }

            undo() {
                if (this.historyStep > 0) {
                    this.historyStep--;
                    this.restoreHistory();
                    this.showShinchanVoice("Êí§ÈîÄÔºÅ");
                }
            }

            redo() {
                if (this.historyStep < this.history.length - 1) {
                    this.historyStep++;
                    this.restoreHistory();
                    this.showShinchanVoice("ÈáçÂÅöÔºÅ");
                }
            }

            restoreHistory() {
                const img = new Image();
                img.src = this.history[this.historyStep];
                img.onload = () => {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.drawImage(img, 0, 0);
                };
            }

            clearCanvas() {
                if (confirm('Â∞èÊñ∞Ë¶ÅÊääÁîªÁîªÈÉΩÊì¶ÊéâÂíØÔºåÁ°ÆÂÆöÂêóÔºü')) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.saveHistory();
                    this.showShinchanVoice("ÂÖ®ÈÉ®Ê∏ÖÁ©∫‰∫ÜÔºÅ");
                }
            }

            newCanvas() {
                if (confirm('Ë¶ÅÊñ∞Âª∫‰∏Ä‰∏™ÁîªÂ∏ÉÂêóÔºüÂΩìÂâçÁöÑÁîª‰ºöÊ∂àÂ§±Âì¶ÔºÅ')) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.history = [];
                    this.historyStep = -1;
                    this.saveHistory();
                    this.showShinchanVoice("Êñ∞ÁöÑÁîªÂ∏ÉÂáÜÂ§áÂ•Ω‰∫ÜÔºÅ");
                }
            }

            saveImage() {
                const link = document.createElement('a');
                link.download = 'Â∞èÊñ∞ÁöÑÁîª‰Ωú_' + Date.now() + '.png';
                link.href = this.canvas.toDataURL();
                link.click();
                this.showShinchanVoice("‰øùÂ≠òÊàêÂäüÔºÅÁªôÂ¶àÂ¶àÁúãÁúã~");
            }

            togglePanel() {
                const panel = document.getElementById('sidePanel');
                panel.classList.toggle('open');
            }

            addLayer() {
                const layersList = document.getElementById('layersList');
                const layerCount = layersList.children.length + 1;

                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';
                layerItem.innerHTML = `
                    <span>üìÑ</span>
                    <span>ÂõæÂ±Ç ${layerCount}</span>
                    <span style="margin-left: auto;">üëÅÔ∏è</span>
                `;

                layersList.insertBefore(layerItem, layersList.firstChild);
                this.showShinchanVoice(`Ê∑ªÂä†‰∫ÜÂõæÂ±Ç ${layerCount}ÔºÅ`);
            }

            handleKeyDown(e) {
                // Âø´Êç∑ÈîÆ
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 'z':
                            e.preventDefault();
                            this.undo();
                            break;
                        case 'y':
                            e.preventDefault();
                            this.redo();
                            break;
                        case 's':
                            e.preventDefault();
                            this.saveImage();
                            break;
                    }
                }

                // Â∑•ÂÖ∑Âø´Êç∑ÈîÆ
                switch(e.key) {
                    case 'b':
                        this.selectTool('brush');
                        break;
                    case 'e':
                        this.selectTool('eraser');
                        break;
                    case 'i':
                        this.selectTool('eyedropper');
                        break;
                }
            }

            handleResize() {
                // ÈáçÊñ∞ËÆæÁΩÆÁîªÂ∏ÉÂ§ßÂ∞è
                // Ê≥®ÊÑèÔºöËøô‰ºöÊ∏ÖÁ©∫ÁîªÂ∏ÉÔºåÊâÄ‰ª•ÈúÄË¶ÅÊÅ¢Â§çÂÜÖÂÆπ
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(this.canvas, 0, 0);

                this.setupCanvas();

                // ÊÅ¢Â§çÂÜÖÂÆπ
                this.ctx.drawImage(tempCanvas, 0, 0);
            }
        }

        // ÂêØÂä®Â∫îÁî®
        window.addEventListener('DOMContentLoaded', () => {
            window.app = new DrawingApp();
        });

        // Èò≤Ê≠¢iOS SafariÁöÑÊ©°ÁöÆÁ≠ãÊïàÊûú
        document.body.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });

        // Service WorkerÊ≥®ÂÜåÔºàÁî®‰∫éPWAÔºâ
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        }
    </script>
</body>
</html>