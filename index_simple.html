<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <title>å°æ–°çš„è¶…çº§ç”»ç”»æ¿ Pro ğŸ–ï¸</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --shinchan-red: #FF6B6B;
            --shinchan-yellow: #FFD93D;
            --shinchan-blue: #6BCF7F;
            --shinchan-pink: #FFB6C1;
            --shinchan-purple: #C589E8;
            --panel-bg: rgba(255, 255, 255, 0.98);
            --shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
            --radius: 20px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: "Comic Sans MS", "å¾®è½¯é›…é»‘", -apple-system, BlinkMacSystemFont, sans-serif;
            overflow: hidden;
            touch-action: none;
            background: linear-gradient(135deg, #FFE5B4 0%, #FFB6C1 25%, #C3B1E1 50%, #B4E7CE 75%, #FFDAB9 100%);
            background-size: 400% 400%;
            animation: gradientShift 15s ease infinite;
            -webkit-user-select: none;
            user-select: none;
            position: fixed;
            width: 100%;
            height: 100vh;
            overscroll-behavior: none;
        }

        @keyframes gradientShift {
            0% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
            100% { background-position: 0% 50%; }
        }

        /* é¡¶éƒ¨æ ‡é¢˜æ  - å°æ–°é£æ ¼ */
        .header {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            height: 60px;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 2px 20px rgba(255, 107, 107, 0.2);
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 0 env(safe-area-inset-right, 20px) 0 env(safe-area-inset-left, 20px);
            z-index: 1000;
            transition: var(--transition);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 18px;
            font-weight: bold;
            background: linear-gradient(135deg, var(--shinchan-red), var(--shinchan-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: bounce 2s infinite;
        }

        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-5px); }
        }

        .shinchan-avatar {
            width: 40px;
            height: 40px;
            background: var(--shinchan-yellow);
            border-radius: 50%;
            position: relative;
            animation: wiggle 3s infinite;
        }

        @keyframes wiggle {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-5deg); }
            75% { transform: rotate(5deg); }
        }

        .shinchan-avatar::before {
            content: "ğŸ˜Š";
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 24px;
        }

        /* ç”»å¸ƒå®¹å™¨ */
        .canvas-container {
            position: fixed;
            top: 60px;
            left: 0;
            right: 0;
            bottom: 120px;
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 20px;
        }

        .canvas-wrapper {
            position: relative;
            background: white;
            border-radius: var(--radius);
            box-shadow: var(--shadow);
            max-width: 100%;
            max-height: 100%;
            animation: fadeIn 0.5s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: scale(0.9); }
            to { opacity: 1; transform: scale(1); }
        }

        canvas {
            display: block;
            border-radius: var(--radius);
            cursor: crosshair;
            touch-action: none;
        }

        /* è‡ªå®šä¹‰ç”»ç¬”å…‰æ ‡ */
        .custom-cursor {
            position: fixed;
            pointer-events: none;
            z-index: 9999;
            transition: transform 0.1s ease;
        }

        .cursor-ring {
            border: 2px solid var(--shinchan-red);
            border-radius: 50%;
            position: absolute;
            transform: translate(-50%, -50%);
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }

        /* åº•éƒ¨å·¥å…·æ  - ç®€æ´ä½†åä¸½ */
        .toolbar {
            position: fixed;
            bottom: env(safe-area-inset-bottom, 0);
            left: 0;
            right: 0;
            height: 120px;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: 0 -2px 20px rgba(0, 0, 0, 0.1);
            padding: 10px;
            z-index: 1000;
            transition: var(--transition);
        }

        .toolbar-content {
            display: flex;
            flex-direction: column;
            gap: 10px;
            height: 100%;
        }

        .tool-row {
            display: flex;
            gap: 10px;
            align-items: center;
            justify-content: center;
            flex-wrap: wrap;
        }

        /* å·¥å…·æŒ‰é’® - å¯çˆ±é£æ ¼ */
        .tool-btn {
            width: 50px;
            height: 50px;
            border: 2px solid transparent;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .tool-btn::before {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, var(--shinchan-yellow) 0%, transparent 70%);
            transform: translate(-50%, -50%);
            transition: width 0.3s, height 0.3s;
        }

        .tool-btn:active::before {
            width: 100px;
            height: 100px;
        }

        .tool-btn:hover {
            transform: translateY(-3px) scale(1.1);
            box-shadow: 0 5px 15px rgba(255, 107, 107, 0.3);
            border-color: var(--shinchan-red);
        }

        .tool-btn.active {
            background: linear-gradient(135deg, var(--shinchan-yellow), var(--shinchan-pink));
            border-color: var(--shinchan-red);
            animation: toolActive 0.5s ease;
        }

        @keyframes toolActive {
            0% { transform: scale(1); }
            50% { transform: scale(1.2) rotate(10deg); }
            100% { transform: scale(1); }
        }

        /* é¢œè‰²é€‰æ‹©å™¨ - å½©è™¹é£æ ¼ */
        .color-picker-container {
            display: flex;
            gap: 8px;
            align-items: center;
        }

        .color-wheel-mini {
            width: 50px;
            height: 50px;
            border-radius: 50%;
            background: conic-gradient(from 0deg, red, yellow, lime, cyan, blue, magenta, red);
            cursor: pointer;
            position: relative;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.2);
            transition: var(--transition);
        }

        .color-wheel-mini:hover {
            transform: scale(1.1) rotate(180deg);
        }

        .current-color {
            width: 30px;
            height: 30px;
            border-radius: 50%;
            border: 3px solid white;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        }

        /* ç¬”åˆ·å¤§å°æ»‘å— - å¯çˆ±é£æ ¼ */
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 0 10px;
        }

        .slider {
            -webkit-appearance: none;
            width: 120px;
            height: 8px;
            border-radius: 10px;
            background: linear-gradient(to right, var(--shinchan-blue), var(--shinchan-yellow), var(--shinchan-red));
            outline: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: white;
            border: 3px solid var(--shinchan-red);
            cursor: pointer;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
            transition: var(--transition);
        }

        .slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .size-preview {
            width: 30px;
            height: 30px;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
        }

        .size-dot {
            background: var(--shinchan-red);
            border-radius: 50%;
            transition: var(--transition);
        }

        /* ä¾§è¾¹é¢æ¿ - æ»‘å‡ºå¼ */
        .side-panel {
            position: fixed;
            top: 60px;
            right: -300px;
            width: 300px;
            bottom: 120px;
            background: var(--panel-bg);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            box-shadow: -2px 0 20px rgba(0, 0, 0, 0.1);
            transition: var(--transition);
            z-index: 999;
            padding: 20px;
            overflow-y: auto;
        }

        .side-panel.open {
            right: 0;
        }

        .panel-toggle {
            position: fixed;
            right: 10px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 80px;
            background: var(--panel-bg);
            border-radius: 20px 0 0 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            box-shadow: -2px 0 10px rgba(0, 0, 0, 0.1);
            z-index: 998;
            transition: var(--transition);
        }

        .panel-toggle:hover {
            transform: translateY(-50%) translateX(-5px);
        }

        /* å›¾å±‚é¢æ¿ */
        .layers-section {
            margin-bottom: 20px;
        }

        .section-title {
            font-size: 16px;
            font-weight: bold;
            color: var(--shinchan-red);
            margin-bottom: 10px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .layer-item {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 10px;
            background: white;
            border-radius: 10px;
            margin-bottom: 5px;
            cursor: pointer;
            transition: var(--transition);
        }

        .layer-item:hover {
            transform: translateX(5px);
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .layer-item.active {
            background: linear-gradient(135deg, rgba(255, 215, 0, 0.2), rgba(255, 182, 193, 0.2));
            border: 2px solid var(--shinchan-yellow);
        }

        /* ç¬”åˆ·é¢„è®¾ - å¡ç‰‡é£æ ¼ */
        .brush-presets {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 10px;
            margin-bottom: 20px;
        }

        .brush-preset {
            aspect-ratio: 1;
            background: white;
            border-radius: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 5px;
            cursor: pointer;
            transition: var(--transition);
            border: 2px solid transparent;
        }

        .brush-preset:hover {
            transform: scale(1.05);
            border-color: var(--shinchan-pink);
        }

        .brush-preset.active {
            background: linear-gradient(135deg, var(--shinchan-yellow), var(--shinchan-pink));
            animation: bounce 0.5s;
        }

        .brush-icon {
            font-size: 24px;
        }

        .brush-name {
            font-size: 10px;
            color: #666;
        }

        /* å°æ–°è¯­éŸ³æ°”æ³¡ */
        .shinchan-bubble {
            position: fixed;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            background: white;
            padding: 15px 25px;
            border-radius: 20px;
            box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
            font-size: 14px;
            color: var(--shinchan-red);
            opacity: 0;
            pointer-events: none;
            transition: var(--transition);
            z-index: 1001;
        }

        .shinchan-bubble.show {
            opacity: 1;
            animation: bubblePop 0.5s ease;
        }

        @keyframes bubblePop {
            0% { transform: translateX(-50%) scale(0.5); opacity: 0; }
            50% { transform: translateX(-50%) scale(1.1); }
            100% { transform: translateX(-50%) scale(1); opacity: 1; }
        }

        .shinchan-bubble::before {
            content: "ğŸ¤ å°æ–°è¯´ï¼š";
            display: block;
            font-size: 12px;
            margin-bottom: 5px;
            color: var(--shinchan-purple);
        }

        /* å‹åŠ›æŒ‡ç¤ºå™¨ */
        .pressure-indicator {
            position: fixed;
            top: 80px;
            right: 20px;
            background: white;
            padding: 10px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            display: none;
            z-index: 100;
            min-width: 120px;
        }

        .pressure-indicator.show {
            display: block;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from { transform: translateX(20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .pressure-bar {
            width: 100%;
            height: 8px;
            background: #f0f0f0;
            border-radius: 10px;
            overflow: hidden;
            margin-top: 5px;
        }

        .pressure-fill {
            height: 100%;
            background: linear-gradient(to right, var(--shinchan-blue), var(--shinchan-yellow), var(--shinchan-red));
            width: 0%;
            transition: width 0.1s;
        }

        /* ç‰¹æ•ˆæŒ‰é’® */
        .effect-btn {
            padding: 8px 16px;
            background: linear-gradient(135deg, var(--shinchan-purple), var(--shinchan-pink));
            color: white;
            border: none;
            border-radius: 20px;
            font-size: 12px;
            font-weight: bold;
            cursor: pointer;
            transition: var(--transition);
        }

        .effect-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(197, 137, 232, 0.4);
        }

        /* å“åº”å¼ä¼˜åŒ– */
        @media (max-width: 768px) {
            .header {
                height: 50px;
            }

            .logo {
                font-size: 14px;
            }

            .shinchan-avatar {
                width: 35px;
                height: 35px;
            }

            .canvas-container {
                top: 50px;
                bottom: 100px;
                padding: 10px;
            }

            .toolbar {
                height: 100px;
            }

            .tool-btn {
                width: 40px;
                height: 40px;
                font-size: 20px;
            }

            .slider {
                width: 80px;
            }

            .side-panel {
                width: 250px;
                right: -250px;
            }
        }

        /* iPadä¸“å±ä¼˜åŒ– */
        @supports (-webkit-touch-callout: none) {
            .toolbar {
                padding-bottom: env(safe-area-inset-bottom, 10px);
            }

            .tool-btn {
                -webkit-touch-callout: none;
            }

            .slider {
                height: 44px;
                min-height: 44px;
            }

            .slider::-webkit-slider-thumb {
                width: 32px;
                height: 32px;
            }
        }

        /* åŠ è½½åŠ¨ç”» */
        .loader {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, var(--shinchan-yellow), var(--shinchan-pink));
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 10000;
            transition: opacity 0.5s;
        }

        .loader.hide {
            opacity: 0;
            pointer-events: none;
        }

        .loader-content {
            text-align: center;
        }

        .loader-shinchan {
            font-size: 80px;
            animation: rotate 2s linear infinite;
        }

        @keyframes rotate {
            to { transform: rotate(360deg); }
        }

        .loader-text {
            color: white;
            font-size: 18px;
            margin-top: 20px;
            font-weight: bold;
        }

        /* æ€§èƒ½ä¼˜åŒ– */
        @media (prefers-reduced-motion: reduce) {
            * {
                animation: none !important;
                transition: none !important;
            }
        }

        /* æš—è‰²æ¨¡å¼æ”¯æŒ */
        @media (prefers-color-scheme: dark) {
            :root {
                --panel-bg: rgba(30, 30, 30, 0.95);
            }

            body {
                background: linear-gradient(135deg, #2C3E50, #34495E, #2C3E50);
            }
        }

        /* è§¦æ‘¸åé¦ˆ */
        .touchable {
            position: relative;
            overflow: hidden;
        }

        .touchable::after {
            content: "";
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.5);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .touchable:active::after {
            width: 200px;
            height: 200px;
        }
    </style>
</head>
<body>
    <!-- åŠ è½½åŠ¨ç”» -->
    <div class="loader" id="loader">
        <div class="loader-content">
            <div class="loader-shinchan">ğŸ¨</div>
            <div class="loader-text">å°æ–°æ­£åœ¨å‡†å¤‡ç”»å…·...</div>
        </div>
    </div>

    <!-- å¤´éƒ¨ -->
    <div class="header">
        <div class="logo">
            <div class="shinchan-avatar"></div>
            <span>å°æ–°çš„è¶…çº§ç”»ç”»æ¿</span>
        </div>
        <div style="display: flex; gap: 10px;">
            <button class="effect-btn" onclick="app.newCanvas()">æ–°å»º</button>
            <button class="effect-btn" onclick="app.saveImage()">ä¿å­˜</button>
            <button class="effect-btn" onclick="app.togglePanel()">å·¥å…·</button>
        </div>
    </div>

    <!-- ç”»å¸ƒå®¹å™¨ -->
    <div class="canvas-container">
        <div class="canvas-wrapper">
            <canvas id="mainCanvas"></canvas>
        </div>
    </div>

    <!-- è‡ªå®šä¹‰å…‰æ ‡ -->
    <div class="custom-cursor" id="customCursor" style="display: none;">
        <div class="cursor-ring" id="cursorRing"></div>
    </div>

    <!-- å°æ–°è¯­éŸ³æ°”æ³¡ -->
    <div class="shinchan-bubble" id="shinchanBubble"></div>

    <!-- å‹åŠ›æŒ‡ç¤ºå™¨ -->
    <div class="pressure-indicator" id="pressureIndicator">
        <div style="font-size: 12px; font-weight: bold;">Apple Pencil</div>
        <div class="pressure-bar">
            <div class="pressure-fill" id="pressureFill"></div>
        </div>
        <div style="font-size: 10px; margin-top: 5px;">
            å‹åŠ›: <span id="pressureValue">0%</span>
        </div>
    </div>

    <!-- åº•éƒ¨å·¥å…·æ  -->
    <div class="toolbar">
        <div class="toolbar-content">
            <!-- ç¬¬ä¸€è¡Œï¼šä¸»è¦å·¥å…· -->
            <div class="tool-row">
                <button class="tool-btn active touchable" data-tool="brush" onclick="app.selectTool('brush')">âœï¸</button>
                <button class="tool-btn touchable" data-tool="eraser" onclick="app.selectTool('eraser')">ğŸ§¹</button>
                <button class="tool-btn touchable" data-tool="fill" onclick="app.selectTool('fill')">ğŸª£</button>
                <button class="tool-btn touchable" data-tool="eyedropper" onclick="app.selectTool('eyedropper')">ğŸ’‰</button>
                <button class="tool-btn touchable" data-tool="shape" onclick="app.selectTool('shape')">â­•</button>
                <button class="tool-btn touchable" data-tool="text" onclick="app.selectTool('text')">ğŸ“</button>
                <button class="tool-btn touchable" onclick="app.undo()">â†©ï¸</button>
                <button class="tool-btn touchable" onclick="app.redo()">â†ªï¸</button>
                <button class="tool-btn touchable" onclick="app.clearCanvas()">ğŸ—‘ï¸</button>
            </div>

            <!-- ç¬¬äºŒè¡Œï¼šé¢œè‰²å’Œå¤§å° -->
            <div class="tool-row">
                <div class="color-picker-container">
                    <div class="color-wheel-mini" onclick="app.showColorPicker()">
                        <div class="current-color" id="currentColor"></div>
                    </div>
                </div>

                <div class="slider-container">
                    <span style="font-size: 12px;">ç²—ç»†:</span>
                    <input type="range" class="slider" id="brushSize" min="1" max="100" value="5">
                    <div class="size-preview">
                        <div class="size-dot" id="sizeDot"></div>
                    </div>
                </div>

                <select style="padding: 8px; border-radius: 10px; border: 2px solid var(--shinchan-pink);" id="brushEffect">
                    <option value="normal">æ™®é€š</option>
                    <option value="watercolor">æ°´å½©</option>
                    <option value="crayon">èœ¡ç¬”</option>
                    <option value="marker">é©¬å…‹ç¬”</option>
                    <option value="spray">å–·é›¾</option>
                </select>
            </div>
        </div>
    </div>

    <!-- ä¾§è¾¹é¢æ¿ -->
    <div class="side-panel" id="sidePanel">
        <!-- ç¬”åˆ·é¢„è®¾ -->
        <div class="section-title">
            <span>ğŸ–Œï¸</span>
            <span>ç¬”åˆ·åº“</span>
        </div>
        <div class="brush-presets">
            <div class="brush-preset" data-brush="pencil">
                <div class="brush-icon">âœï¸</div>
                <div class="brush-name">é“…ç¬”</div>
            </div>
            <div class="brush-preset" data-brush="pen">
                <div class="brush-icon">ğŸ–Šï¸</div>
                <div class="brush-name">é’¢ç¬”</div>
            </div>
            <div class="brush-preset" data-brush="marker">
                <div class="brush-icon">ğŸ–ï¸</div>
                <div class="brush-name">é©¬å…‹ç¬”</div>
            </div>
            <div class="brush-preset" data-brush="watercolor">
                <div class="brush-icon">ğŸ¨</div>
                <div class="brush-name">æ°´å½©</div>
            </div>
            <div class="brush-preset" data-brush="crayon">
                <div class="brush-icon">ğŸ–ï¸</div>
                <div class="brush-name">èœ¡ç¬”</div>
            </div>
            <div class="brush-preset" data-brush="spray">
                <div class="brush-icon">ğŸ’¨</div>
                <div class="brush-name">å–·æª</div>
            </div>
        </div>

        <!-- å›¾å±‚ -->
        <div class="layers-section">
            <div class="section-title">
                <span>ğŸ“š</span>
                <span>å›¾å±‚</span>
                <button style="margin-left: auto;" class="effect-btn" onclick="app.addLayer()">+</button>
            </div>
            <div id="layersList">
                <div class="layer-item active">
                    <span>ğŸ“„</span>
                    <span>å›¾å±‚ 1</span>
                    <span style="margin-left: auto;">ğŸ‘ï¸</span>
                </div>
            </div>
        </div>

        <!-- é«˜çº§è®¾ç½® -->
        <div class="section-title">
            <span>âš™ï¸</span>
            <span>é«˜çº§è®¾ç½®</span>
        </div>
        <div style="display: flex; flex-direction: column; gap: 10px;">
            <label style="font-size: 12px;">
                <input type="checkbox" id="pressureEnabled" checked> å‹åŠ›æ„Ÿåº”
            </label>
            <label style="font-size: 12px;">
                <input type="checkbox" id="smoothingEnabled" checked> ç¬”è§¦å¹³æ»‘
            </label>
            <label style="font-size: 12px;">
                <input type="checkbox" id="symmetryEnabled"> å¯¹ç§°ç»˜åˆ¶
            </label>
        </div>
    </div>

    <!-- é¢æ¿åˆ‡æ¢æŒ‰é’® -->
    <div class="panel-toggle" onclick="app.togglePanel()">
        <span>ğŸ¨</span>
    </div>

    <script>
        // å°æ–°çš„è¯­éŸ³åº“
        const shinchanVoices = {
            brush: ["è¦å¼€å§‹ç”»ç”»å’¯~", "åŠ¨æ„Ÿè¶…äººç”»ç¬”ï¼Œå˜èº«ï¼", "å°æ–°è¦ç”»ç¾å¥³å§å§~"],
            eraser: ["æ©¡çš®æ“¦æ“¦æ“¦~", "æŠŠä¸å¥½çœ‹çš„éƒ½æ“¦æ‰ï¼", "å¦ˆå¦ˆçš„æ‹³å¤´åƒæ©¡çš®æ“¦"],
            fill: ["å€’é¢œæ–™å’¯~", "å“—å•¦å•¦å¡«æ»¡å®ƒï¼", "åƒæ´’äº†æœæ±ä¸€æ ·"],
            clear: ["å…¨éƒ¨æ¸…ç©ºï¼é‡æ–°å¼€å§‹ï¼", "å“‡ï¼Œéƒ½æ²¡äº†~", "å¦ˆå¦ˆè¦ç”Ÿæ°”äº†ï¼Œèµ¶ç´§æ¸…ç©ºï¼"],
            save: ["ä¿å­˜å°æ–°çš„å¤§ä½œï¼", "è¦ç»™å¦ˆå¦ˆçœ‹çœ‹~", "åŠ¨æ„Ÿè¶…äººè®¤è¯ä½œå“ï¼"],
            undo: ["å•Šï¼Œç”»é”™äº†ï¼Œé€€å›å»ï¼", "æ—¶å…‰å€’æµæœ¯ï¼", "æ’¤é”€æ’¤é”€~"],
            redo: ["é‡æ–°åšä¸€éï¼", "å†æ¥ä¸€æ¬¡ï¼", "åŠ¨æ„Ÿæ¢å¤æœ¯ï¼"]
        };

        class DrawingApp {
            constructor() {
                this.canvas = document.getElementById('mainCanvas');
                this.ctx = this.canvas.getContext('2d', {
                    willReadFrequently: true,
                    alpha: true,
                    desynchronized: true
                });

                // è®¾ç½®ç”»å¸ƒ
                this.setupCanvas();

                // å·¥å…·çŠ¶æ€
                this.currentTool = 'brush';
                this.currentColor = '#FF6B6B';
                this.brushSize = 5;
                this.brushEffect = 'normal';
                this.isDrawing = false;
                this.lastPoint = null;

                // å‹åŠ›å’Œå€¾æ–œ
                this.pressure = 1;
                this.tiltX = 0;
                this.tiltY = 0;
                this.velocity = 0;
                this.lastTime = 0;

                // å†å²è®°å½•
                this.history = [];
                this.historyStep = -1;

                // å›¾å±‚ç³»ç»Ÿ
                this.layers = [];
                this.currentLayer = 0;

                // è®¾ç½®
                this.pressureEnabled = true;
                this.smoothingEnabled = true;
                this.symmetryEnabled = false;

                // åˆå§‹åŒ–
                this.init();
            }

            init() {
                // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬
                this.setupEventListeners();

                // åˆå§‹åŒ–UI
                this.setupUI();

                // ä¿å­˜åˆå§‹çŠ¶æ€
                this.saveHistory();

                // éšè—åŠ è½½åŠ¨ç”»
                setTimeout(() => {
                    document.getElementById('loader').classList.add('hide');
                    this.showShinchanVoice("æ¬¢è¿æ¥åˆ°å°æ–°çš„ç”»ç”»ä¸–ç•Œï¼");
                }, 1000);
            }

            setupCanvas() {
                // å“åº”å¼ç”»å¸ƒå¤§å°
                const container = document.querySelector('.canvas-container');
                const rect = container.getBoundingClientRect();

                // é«˜DPIæ”¯æŒ
                const dpr = window.devicePixelRatio || 1;

                // è®¾ç½®ç”»å¸ƒå°ºå¯¸
                const width = Math.min(rect.width - 40, 1024);
                const height = Math.min(rect.height - 40, 768);

                this.canvas.width = width * dpr;
                this.canvas.height = height * dpr;
                this.canvas.style.width = width + 'px';
                this.canvas.style.height = height + 'px';

                // ç¼©æ”¾ä¸Šä¸‹æ–‡ä»¥åŒ¹é…è®¾å¤‡åƒç´ æ¯”
                this.ctx.scale(dpr, dpr);

                // è®¾ç½®é»˜è®¤æ ·å¼
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.imageSmoothingEnabled = true;
                this.ctx.imageSmoothingQuality = 'high';
            }

            setupEventListeners() {
                // é¼ æ ‡äº‹ä»¶
                this.canvas.addEventListener('mousedown', this.handleStart.bind(this));
                this.canvas.addEventListener('mousemove', this.handleMove.bind(this));
                this.canvas.addEventListener('mouseup', this.handleEnd.bind(this));
                this.canvas.addEventListener('mouseleave', this.handleEnd.bind(this));

                // è§¦æ‘¸äº‹ä»¶
                this.canvas.addEventListener('touchstart', this.handleTouchStart.bind(this), { passive: false });
                this.canvas.addEventListener('touchmove', this.handleTouchMove.bind(this), { passive: false });
                this.canvas.addEventListener('touchend', this.handleTouchEnd.bind(this), { passive: false });
                this.canvas.addEventListener('touchcancel', this.handleTouchEnd.bind(this), { passive: false });

                // Pointer Events (æœ€ä½³æ”¯æŒApple Pencil)
                if (window.PointerEvent) {
                    this.canvas.addEventListener('pointerdown', this.handlePointerDown.bind(this));
                    this.canvas.addEventListener('pointermove', this.handlePointerMove.bind(this));
                    this.canvas.addEventListener('pointerup', this.handlePointerUp.bind(this));
                    this.canvas.addEventListener('pointercancel', this.handlePointerUp.bind(this));
                }

                // é˜»æ­¢é»˜è®¤è§¦æ‘¸è¡Œä¸º
                this.canvas.addEventListener('touchstart', e => e.preventDefault(), { passive: false });
                document.addEventListener('touchmove', e => {
                    if (e.target === this.canvas) e.preventDefault();
                }, { passive: false });

                // çª—å£è°ƒæ•´
                window.addEventListener('resize', this.handleResize.bind(this));

                // é”®ç›˜å¿«æ·é”®
                document.addEventListener('keydown', this.handleKeyDown.bind(this));
            }

            setupUI() {
                // é¢œè‰²é€‰æ‹©
                document.getElementById('currentColor').style.background = this.currentColor;

                // ç”»ç¬”å¤§å°
                const sizeSlider = document.getElementById('brushSize');
                sizeSlider.addEventListener('input', (e) => {
                    this.brushSize = e.target.value;
                    this.updateSizePreview();
                    this.updateCursor();
                });

                // ç”»ç¬”æ•ˆæœ
                document.getElementById('brushEffect').addEventListener('change', (e) => {
                    this.brushEffect = e.target.value;
                    this.showShinchanVoice(`åˆ‡æ¢åˆ°${e.target.selectedOptions[0].text}æ¨¡å¼ï¼`);
                });

                // è®¾ç½®é€‰é¡¹
                document.getElementById('pressureEnabled').addEventListener('change', (e) => {
                    this.pressureEnabled = e.target.checked;
                });

                document.getElementById('smoothingEnabled').addEventListener('change', (e) => {
                    this.smoothingEnabled = e.target.checked;
                });

                document.getElementById('symmetryEnabled').addEventListener('change', (e) => {
                    this.symmetryEnabled = e.target.checked;
                });

                // ç¬”åˆ·é¢„è®¾
                document.querySelectorAll('.brush-preset').forEach(preset => {
                    preset.addEventListener('click', () => {
                        this.selectBrushPreset(preset.dataset.brush);
                        document.querySelectorAll('.brush-preset').forEach(p => p.classList.remove('active'));
                        preset.classList.add('active');
                    });
                });

                // åˆå§‹åŒ–
                this.updateSizePreview();
                this.updateCursor();
            }

            // Pointer Eventså¤„ç†ï¼ˆæœ€ä¼˜å…ˆï¼Œæ”¯æŒApple Pencilï¼‰
            handlePointerDown(e) {
                if (e.pointerType === 'pen' || e.pointerType === 'touch' || e.pointerType === 'mouse') {
                    this.pressure = e.pressure || 1;
                    this.tiltX = e.tiltX || 0;
                    this.tiltY = e.tiltY || 0;

                    // æ˜¾ç¤ºå‹åŠ›æŒ‡ç¤ºå™¨
                    if (e.pointerType === 'pen' && e.pressure) {
                        this.showPressureIndicator();
                        this.updatePressure(e.pressure);
                    }

                    const point = this.getPoint(e);
                    this.startDrawing(point);
                }
            }

            handlePointerMove(e) {
                if (e.pointerType === 'pen' || e.pointerType === 'touch' || e.pointerType === 'mouse') {
                    this.pressure = e.pressure || 1;
                    this.tiltX = e.tiltX || 0;
                    this.tiltY = e.tiltY || 0;

                    if (e.pointerType === 'pen' && e.pressure) {
                        this.updatePressure(e.pressure);
                    }

                    const point = this.getPoint(e);
                    this.continueDrawing(point);
                    this.updateCursorPosition(e);
                }
            }

            handlePointerUp(e) {
                this.stopDrawing();
                this.hidePressureIndicator();
            }

            // è§¦æ‘¸äº‹ä»¶å¤„ç†ï¼ˆå¤‡ç”¨ï¼‰
            handleTouchStart(e) {
                e.preventDefault();
                if (e.touches.length === 1) {
                    const touch = e.touches[0];
                    // æ£€æµ‹Apple Pencil
                    if (touch.force !== undefined) {
                        this.pressure = touch.force;
                        this.showPressureIndicator();
                        this.updatePressure(touch.force);
                    }

                    if (touch.altitudeAngle !== undefined) {
                        // iPadç‰¹æœ‰çš„å€¾æ–œè§’åº¦
                        const altitude = touch.altitudeAngle;
                        const azimuth = touch.azimuthAngle;
                        this.tiltX = Math.cos(azimuth) * (90 - altitude * 180 / Math.PI);
                        this.tiltY = Math.sin(azimuth) * (90 - altitude * 180 / Math.PI);
                    }

                    const point = this.getPoint(touch);
                    this.startDrawing(point);
                }
            }

            handleTouchMove(e) {
                e.preventDefault();
                if (e.touches.length === 1 && this.isDrawing) {
                    const touch = e.touches[0];
                    if (touch.force !== undefined) {
                        this.pressure = touch.force;
                        this.updatePressure(touch.force);
                    }

                    const point = this.getPoint(touch);
                    this.continueDrawing(point);
                }
            }

            handleTouchEnd(e) {
                e.preventDefault();
                this.stopDrawing();
                this.hidePressureIndicator();
            }

            // é¼ æ ‡äº‹ä»¶å¤„ç†ï¼ˆæœ€ä½ä¼˜å…ˆçº§ï¼‰
            handleStart(e) {
                // å¦‚æœå·²ç»æœ‰Pointeræˆ–Touchäº‹ä»¶å¤„ç†ï¼Œåˆ™å¿½ç•¥é¼ æ ‡äº‹ä»¶
                if (!window.PointerEvent) {
                    const point = this.getPoint(e);
                    this.startDrawing(point);
                }
            }

            handleMove(e) {
                if (!window.PointerEvent) {
                    const point = this.getPoint(e);
                    this.continueDrawing(point);
                    this.updateCursorPosition(e);
                }
            }

            handleEnd(e) {
                if (!window.PointerEvent) {
                    this.stopDrawing();
                }
            }

            getPoint(e) {
                const rect = this.canvas.getBoundingClientRect();
                const dpr = window.devicePixelRatio || 1;

                // å¤„ç†ä¸åŒç±»å‹çš„äº‹ä»¶
                let clientX, clientY;
                if (e.touches) {
                    clientX = e.touches[0].clientX;
                    clientY = e.touches[0].clientY;
                } else if (e.changedTouches) {
                    clientX = e.changedTouches[0].clientX;
                    clientY = e.changedTouches[0].clientY;
                } else {
                    clientX = e.clientX;
                    clientY = e.clientY;
                }

                return {
                    x: (clientX - rect.left) * (this.canvas.width / dpr / rect.width),
                    y: (clientY - rect.top) * (this.canvas.height / dpr / rect.height)
                };
            }

            startDrawing(point) {
                this.isDrawing = true;
                this.lastPoint = point;
                this.lastTime = performance.now();

                // æ ¹æ®å·¥å…·æ‰§è¡Œæ“ä½œ
                if (this.currentTool === 'eyedropper') {
                    this.pickColor(point);
                    return;
                }

                if (this.currentTool === 'fill') {
                    this.fillArea(point);
                    this.saveHistory();
                    return;
                }

                // å¼€å§‹ç»˜åˆ¶è·¯å¾„
                this.ctx.beginPath();
                this.ctx.moveTo(point.x, point.y);
            }

            continueDrawing(point) {
                if (!this.isDrawing) return;

                if (this.currentTool === 'eyedropper') return;

                // è®¡ç®—é€Ÿåº¦
                const now = performance.now();
                const dt = now - this.lastTime;
                if (this.lastPoint && dt > 0) {
                    const distance = Math.sqrt(
                        Math.pow(point.x - this.lastPoint.x, 2) +
                        Math.pow(point.y - this.lastPoint.y, 2)
                    );
                    this.velocity = distance / dt;
                }
                this.lastTime = now;

                // åº”ç”¨å¹³æ»‘
                if (this.smoothingEnabled && this.lastPoint) {
                    point = this.smoothPoint(this.lastPoint, point);
                }

                // ç»˜åˆ¶
                this.drawStroke(this.lastPoint, point);

                // å¯¹ç§°ç»˜åˆ¶
                if (this.symmetryEnabled) {
                    this.drawSymmetry(this.lastPoint, point);
                }

                this.lastPoint = point;
            }

            stopDrawing() {
                if (this.isDrawing) {
                    this.isDrawing = false;
                    this.lastPoint = null;

                    // ä¿å­˜å†å²
                    if (this.currentTool !== 'eyedropper') {
                        this.saveHistory();
                    }
                }
            }

            drawStroke(from, to) {
                const ctx = this.ctx;

                // è®¾ç½®æ ·å¼
                this.setupBrushStyle();

                // è®¡ç®—å®é™…å¤§å°ï¼ˆåº”ç”¨å‹åŠ›ï¼‰
                let size = this.brushSize;
                if (this.pressureEnabled) {
                    size *= (0.3 + this.pressure * 0.7);
                }

                // æ ¹æ®æ•ˆæœç»˜åˆ¶
                switch (this.brushEffect) {
                    case 'watercolor':
                        this.drawWatercolor(from, to, size);
                        break;
                    case 'crayon':
                        this.drawCrayon(from, to, size);
                        break;
                    case 'marker':
                        this.drawMarker(from, to, size);
                        break;
                    case 'spray':
                        this.drawSpray(from, to, size);
                        break;
                    default:
                        // æ™®é€šç”»ç¬”
                        ctx.lineWidth = size;
                        ctx.strokeStyle = this.currentTool === 'eraser' ? 'white' : this.currentColor;
                        ctx.globalCompositeOperation = this.currentTool === 'eraser' ? 'destination-out' : 'source-over';

                        ctx.beginPath();
                        ctx.moveTo(from.x, from.y);
                        ctx.lineTo(to.x, to.y);
                        ctx.stroke();
                }
            }

            drawWatercolor(from, to, size) {
                const ctx = this.ctx;
                ctx.globalAlpha = 0.1;
                ctx.strokeStyle = this.currentColor;
                ctx.lineWidth = size * 2;
                ctx.shadowBlur = size;
                ctx.shadowColor = this.currentColor;

                for (let i = 0; i < 5; i++) {
                    ctx.beginPath();
                    ctx.moveTo(from.x + Math.random() * 4 - 2, from.y + Math.random() * 4 - 2);
                    ctx.lineTo(to.x + Math.random() * 4 - 2, to.y + Math.random() * 4 - 2);
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;
                ctx.shadowBlur = 0;
            }

            drawCrayon(from, to, size) {
                const ctx = this.ctx;
                ctx.globalAlpha = 0.6;
                ctx.strokeStyle = this.currentColor;

                for (let i = 0; i < 3; i++) {
                    ctx.lineWidth = size + Math.random() * 4;
                    ctx.beginPath();
                    ctx.moveTo(from.x + Math.random() * 2, from.y + Math.random() * 2);
                    ctx.lineTo(to.x + Math.random() * 2, to.y + Math.random() * 2);
                    ctx.stroke();
                }

                ctx.globalAlpha = 1;
            }

            drawMarker(from, to, size) {
                const ctx = this.ctx;
                ctx.globalAlpha = 0.5;
                ctx.globalCompositeOperation = 'multiply';
                ctx.strokeStyle = this.currentColor;
                ctx.lineWidth = size * 2;
                ctx.lineCap = 'square';

                ctx.beginPath();
                ctx.moveTo(from.x, from.y);
                ctx.lineTo(to.x, to.y);
                ctx.stroke();

                ctx.globalAlpha = 1;
                ctx.globalCompositeOperation = 'source-over';
                ctx.lineCap = 'round';
            }

            drawSpray(from, to, size) {
                const ctx = this.ctx;
                const distance = Math.sqrt(Math.pow(to.x - from.x, 2) + Math.pow(to.y - from.y, 2));
                const steps = Math.max(1, Math.floor(distance));

                for (let i = 0; i <= steps; i++) {
                    const t = i / steps;
                    const x = from.x + (to.x - from.x) * t;
                    const y = from.y + (to.y - from.y) * t;

                    for (let j = 0; j < 20; j++) {
                        const offsetX = (Math.random() - 0.5) * size * 2;
                        const offsetY = (Math.random() - 0.5) * size * 2;
                        const radius = Math.random() * 2;

                        ctx.fillStyle = this.currentColor;
                        ctx.globalAlpha = 0.1;
                        ctx.beginPath();
                        ctx.arc(x + offsetX, y + offsetY, radius, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }

                ctx.globalAlpha = 1;
            }

            drawSymmetry(from, to) {
                const centerX = this.canvas.width / 2;
                const centerY = this.canvas.height / 2;

                // æ°´å¹³å¯¹ç§°
                const symFrom = { x: centerX * 2 - from.x, y: from.y };
                const symTo = { x: centerX * 2 - to.x, y: to.y };
                this.drawStroke(symFrom, symTo);

                // å‚ç›´å¯¹ç§°
                const symFromV = { x: from.x, y: centerY * 2 - from.y };
                const symToV = { x: to.x, y: centerY * 2 - to.y };
                this.drawStroke(symFromV, symToV);

                // å¯¹è§’å¯¹ç§°
                const symFromD = { x: centerX * 2 - from.x, y: centerY * 2 - from.y };
                const symToD = { x: centerX * 2 - to.x, y: centerY * 2 - to.y };
                this.drawStroke(symFromD, symToD);
            }

            smoothPoint(from, to) {
                const smoothing = 0.5;
                return {
                    x: from.x + (to.x - from.x) * (1 - smoothing),
                    y: from.y + (to.y - from.y) * (1 - smoothing)
                };
            }

            setupBrushStyle() {
                this.ctx.lineCap = 'round';
                this.ctx.lineJoin = 'round';
                this.ctx.imageSmoothingEnabled = true;
            }

            pickColor(point) {
                const imageData = this.ctx.getImageData(point.x, point.y, 1, 1);
                const data = imageData.data;
                const r = data[0];
                const g = data[1];
                const b = data[2];

                this.currentColor = `rgb(${r},${g},${b})`;
                document.getElementById('currentColor').style.background = this.currentColor;
                this.showShinchanVoice("å¸å–äº†è¿™ä¸ªé¢œè‰²ï¼");
            }

            fillArea(point) {
                // ç®€å•çš„å¡«å……å®ç°
                this.ctx.fillStyle = this.currentColor;
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                this.showShinchanVoice("å“—å•¦å•¦ï¼Œå…¨éƒ¨å¡«æ»¡äº†ï¼");
            }

            selectTool(tool) {
                this.currentTool = tool;

                // æ›´æ–°UI
                document.querySelectorAll('.tool-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.tool === tool);
                });

                // æ˜¾ç¤ºå°æ–°è¯­éŸ³
                if (shinchanVoices[tool]) {
                    const voices = shinchanVoices[tool];
                    const voice = voices[Math.floor(Math.random() * voices.length)];
                    this.showShinchanVoice(voice);
                }

                this.updateCursor();
            }

            selectBrushPreset(preset) {
                const presets = {
                    pencil: { size: 2, effect: 'normal', color: '#333333' },
                    pen: { size: 5, effect: 'normal', color: '#000000' },
                    marker: { size: 15, effect: 'marker', color: '#FF6B6B' },
                    watercolor: { size: 20, effect: 'watercolor', color: '#6BCF7F' },
                    crayon: { size: 10, effect: 'crayon', color: '#FFD93D' },
                    spray: { size: 30, effect: 'spray', color: '#C589E8' }
                };

                const p = presets[preset];
                if (p) {
                    this.brushSize = p.size;
                    this.brushEffect = p.effect;
                    this.currentColor = p.color;

                    // æ›´æ–°UI
                    document.getElementById('brushSize').value = p.size;
                    document.getElementById('brushEffect').value = p.effect;
                    document.getElementById('currentColor').style.background = p.color;

                    this.updateSizePreview();
                    this.updateCursor();

                    this.showShinchanVoice(`åˆ‡æ¢åˆ°${preset}ï¼`);
                }
            }

            showColorPicker() {
                // ç®€å•çš„é¢œè‰²é€‰æ‹©
                const colors = ['#FF6B6B', '#FFD93D', '#6BCF7F', '#6BCB7F', '#C589E8', '#000000', '#FFFFFF'];
                const color = colors[Math.floor(Math.random() * colors.length)];
                this.currentColor = color;
                document.getElementById('currentColor').style.background = color;
                this.showShinchanVoice("æ¢ä¸ªé¢œè‰²ç”»ç”»ï¼");
            }

            updateSizePreview() {
                const dot = document.getElementById('sizeDot');
                const size = Math.min(this.brushSize, 30);
                dot.style.width = size + 'px';
                dot.style.height = size + 'px';
                dot.style.background = this.currentColor;
            }

            updateCursor() {
                const cursor = document.getElementById('customCursor');
                const ring = document.getElementById('cursorRing');

                if (this.currentTool === 'brush' || this.currentTool === 'eraser') {
                    cursor.style.display = 'block';
                    ring.style.width = this.brushSize + 'px';
                    ring.style.height = this.brushSize + 'px';
                    ring.style.borderColor = this.currentTool === 'eraser' ? '#FF6B6B' : this.currentColor;
                } else {
                    cursor.style.display = 'none';
                }
            }

            updateCursorPosition(e) {
                const cursor = document.getElementById('customCursor');
                if (cursor.style.display !== 'none') {
                    cursor.style.left = e.clientX + 'px';
                    cursor.style.top = e.clientY + 'px';
                }
            }

            showPressureIndicator() {
                document.getElementById('pressureIndicator').classList.add('show');
            }

            hidePressureIndicator() {
                setTimeout(() => {
                    document.getElementById('pressureIndicator').classList.remove('show');
                }, 1000);
            }

            updatePressure(pressure) {
                const percent = Math.round(pressure * 100);
                document.getElementById('pressureFill').style.width = percent + '%';
                document.getElementById('pressureValue').textContent = percent + '%';
            }

            showShinchanVoice(message) {
                const bubble = document.getElementById('shinchanBubble');
                bubble.textContent = message;
                bubble.classList.add('show');

                // è¯­éŸ³åˆæˆ
                if ('speechSynthesis' in window) {
                    const utterance = new SpeechSynthesisUtterance(message);
                    utterance.lang = 'zh-CN';
                    utterance.rate = 1.2;
                    utterance.pitch = 1.5;
                    speechSynthesis.speak(utterance);
                }

                setTimeout(() => {
                    bubble.classList.remove('show');
                }, 3000);
            }

            saveHistory() {
                this.historyStep++;
                if (this.historyStep < this.history.length) {
                    this.history.length = this.historyStep;
                }
                this.history.push(this.canvas.toDataURL());

                if (this.history.length > 50) {
                    this.history.shift();
                    this.historyStep--;
                }
            }

            undo() {
                if (this.historyStep > 0) {
                    this.historyStep--;
                    this.restoreHistory();
                    this.showShinchanVoice("æ’¤é”€ï¼");
                }
            }

            redo() {
                if (this.historyStep < this.history.length - 1) {
                    this.historyStep++;
                    this.restoreHistory();
                    this.showShinchanVoice("é‡åšï¼");
                }
            }

            restoreHistory() {
                const img = new Image();
                img.src = this.history[this.historyStep];
                img.onload = () => {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.ctx.drawImage(img, 0, 0);
                };
            }

            clearCanvas() {
                if (confirm('å°æ–°è¦æŠŠç”»ç”»éƒ½æ“¦æ‰å’¯ï¼Œç¡®å®šå—ï¼Ÿ')) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.saveHistory();
                    this.showShinchanVoice("å…¨éƒ¨æ¸…ç©ºäº†ï¼");
                }
            }

            newCanvas() {
                if (confirm('è¦æ–°å»ºä¸€ä¸ªç”»å¸ƒå—ï¼Ÿå½“å‰çš„ç”»ä¼šæ¶ˆå¤±å“¦ï¼')) {
                    this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                    this.history = [];
                    this.historyStep = -1;
                    this.saveHistory();
                    this.showShinchanVoice("æ–°çš„ç”»å¸ƒå‡†å¤‡å¥½äº†ï¼");
                }
            }

            saveImage() {
                const link = document.createElement('a');
                link.download = 'å°æ–°çš„ç”»ä½œ_' + Date.now() + '.png';
                link.href = this.canvas.toDataURL();
                link.click();
                this.showShinchanVoice("ä¿å­˜æˆåŠŸï¼ç»™å¦ˆå¦ˆçœ‹çœ‹~");
            }

            togglePanel() {
                const panel = document.getElementById('sidePanel');
                panel.classList.toggle('open');
            }

            addLayer() {
                const layersList = document.getElementById('layersList');
                const layerCount = layersList.children.length + 1;

                const layerItem = document.createElement('div');
                layerItem.className = 'layer-item';
                layerItem.innerHTML = `
                    <span>ğŸ“„</span>
                    <span>å›¾å±‚ ${layerCount}</span>
                    <span style="margin-left: auto;">ğŸ‘ï¸</span>
                `;

                layersList.insertBefore(layerItem, layersList.firstChild);
                this.showShinchanVoice(`æ·»åŠ äº†å›¾å±‚ ${layerCount}ï¼`);
            }

            handleKeyDown(e) {
                // å¿«æ·é”®
                if (e.ctrlKey || e.metaKey) {
                    switch(e.key) {
                        case 'z':
                            e.preventDefault();
                            this.undo();
                            break;
                        case 'y':
                            e.preventDefault();
                            this.redo();
                            break;
                        case 's':
                            e.preventDefault();
                            this.saveImage();
                            break;
                    }
                }

                // å·¥å…·å¿«æ·é”®
                switch(e.key) {
                    case 'b':
                        this.selectTool('brush');
                        break;
                    case 'e':
                        this.selectTool('eraser');
                        break;
                    case 'i':
                        this.selectTool('eyedropper');
                        break;
                }
            }

            handleResize() {
                // é‡æ–°è®¾ç½®ç”»å¸ƒå¤§å°
                // æ³¨æ„ï¼šè¿™ä¼šæ¸…ç©ºç”»å¸ƒï¼Œæ‰€ä»¥éœ€è¦æ¢å¤å†…å®¹
                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = this.canvas.width;
                tempCanvas.height = this.canvas.height;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(this.canvas, 0, 0);

                this.setupCanvas();

                // æ¢å¤å†…å®¹
                this.ctx.drawImage(tempCanvas, 0, 0);
            }
        }

        // å¯åŠ¨åº”ç”¨
        window.addEventListener('DOMContentLoaded', () => {
            window.app = new DrawingApp();
        });

        // é˜²æ­¢iOS Safariçš„æ©¡çš®ç­‹æ•ˆæœ
        document.body.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });

        // Service Workeræ³¨å†Œï¼ˆç”¨äºPWAï¼‰
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('sw.js').catch(() => {});
        }
    </script>
</body>
</html>